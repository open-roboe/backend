"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodegenComposingNativeTypeImpl = exports.CodegenTransformingNativeTypeImpl = exports.CodegenNativeTypeImpl = void 0;
class CodegenNativeTypeImpl {
    constructor(nativeType, additionalTypes) {
        this.nativeType = nativeType;
        if (additionalTypes) {
            this.serializedType = additionalTypes.serializedType !== undefined ? additionalTypes.serializedType : nativeType;
            this.literalType = additionalTypes.literalType !== undefined ? additionalTypes.literalType : nativeType;
            this.concreteType = additionalTypes.concreteType !== undefined ? additionalTypes.concreteType : nativeType;
            this.parentType = additionalTypes.parentType !== undefined ? additionalTypes.parentType : nativeType;
            this.componentType = additionalTypes.componentType !== undefined ? additionalTypes.componentType : null;
        }
        else {
            this.serializedType = nativeType;
            this.literalType = nativeType;
            this.concreteType = nativeType;
            this.parentType = nativeType;
            this.componentType = null;
        }
    }
    toString() {
        return this.nativeType;
    }
    equals(other) {
        return equalNativeType(this, other);
    }
}
exports.CodegenNativeTypeImpl = CodegenNativeTypeImpl;
class CodegenTransformingNativeTypeImpl {
    constructor(wrapped, transformers) {
        this.actualWrapped = wrapped;
        this.transformers = transformers;
    }
    get nativeType() {
        const transformer = this.transformers.nativeType || this.transformers.default;
        if (transformer) {
            return transformer(this.wrapped, this.wrapped.nativeType) || this.wrapped.nativeType;
        }
        else {
            return this.wrapped.nativeType;
        }
    }
    get serializedType() {
        const transformer = this.transformers.serializedType !== undefined ? this.transformers.serializedType : this.transformers.default;
        if (transformer) {
            return transformer(this.wrapped, this.wrapped.serializedType);
        }
        else {
            return this.wrapped.serializedType;
        }
    }
    get literalType() {
        const transformer = this.transformers.literalType !== undefined ? this.transformers.literalType : this.transformers.default;
        if (transformer) {
            return transformer(this.wrapped, this.wrapped.literalType);
        }
        else {
            return this.wrapped.literalType;
        }
    }
    get concreteType() {
        const transformer = this.transformers.concreteType !== undefined ? this.transformers.concreteType : this.transformers.default;
        if (transformer) {
            return transformer(this.wrapped, this.wrapped.concreteType);
        }
        else {
            return this.wrapped.concreteType;
        }
    }
    get parentType() {
        const transformer = this.transformers.parentType !== undefined ? this.transformers.parentType : this.transformers.default;
        if (transformer) {
            return transformer(this.wrapped, this.wrapped.parentType);
        }
        else {
            return this.wrapped.parentType;
        }
    }
    get componentType() {
        const transformers = this.transformers.componentType !== undefined ? this.transformers.componentType : this.transformers;
        if (transformers) {
            return new CodegenTransformingNativeTypeImpl(this.wrapped.componentType || this.wrapped, transformers);
        }
        else {
            return this.wrapped.componentType;
        }
    }
    get wrapped() {
        return this.actualWrapped;
    }
    equals(other) {
        return equalNativeType(this, other);
    }
    toString() {
        return this.nativeType;
    }
}
exports.CodegenTransformingNativeTypeImpl = CodegenTransformingNativeTypeImpl;
class CodegenComposingNativeTypeImpl {
    constructor(wrapped, composers) {
        this.actualWrapped = wrapped;
        this.composers = composers;
    }
    get nativeType() {
        return this.compose(this.wrapped, this.composers.nativeType || this.composers.default) || this.wrapped.map(n => n.nativeType).filter(n => !!n)[0];
    }
    get serializedType() {
        return this.compose(this.wrapped, this.composers.serializedType || this.composers.default);
    }
    get literalType() {
        return this.compose(this.wrapped, this.composers.literalType || this.composers.default);
    }
    get concreteType() {
        return this.compose(this.wrapped, this.composers.concreteType || this.composers.default);
    }
    get parentType() {
        return this.compose(this.wrapped, this.composers.parentType || this.composers.default);
    }
    get componentType() {
        const wrapped = this.wrapped;
        const componentTypes = wrapped.map(n => n.componentType).filter(n => !!n);
        if (componentTypes.length === wrapped.length) {
            return new CodegenComposingNativeTypeImpl(componentTypes, this.composers);
        }
        else {
            return null;
        }
    }
    get wrapped() {
        return this.actualWrapped;
    }
    equals(other) {
        return equalNativeType(this, other);
    }
    toString() {
        return this.nativeType;
    }
    compose(nativeTypes, composer) {
        return composer(nativeTypes);
    }
}
exports.CodegenComposingNativeTypeImpl = CodegenComposingNativeTypeImpl;
function equalNativeType(a, b) {
    if (!b) {
        return false;
    }
    if (a.nativeType !== b.nativeType) {
        return false;
    }
    if (a.serializedType !== b.serializedType) {
        return false;
    }
    if (a.literalType !== b.literalType) {
        return false;
    }
    if (a.concreteType !== b.concreteType) {
        return false;
    }
    if (a.parentType !== b.parentType) {
        return false;
    }
    if (a.componentType !== b.componentType) {
        return false;
    }
    return true;
}
