"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processDocument = void 0;
const types_1 = require("@openapi-generator-plus/types");
const openapi_type_guards_1 = require("./openapi-type-guards");
const lodash_1 = __importDefault(require("lodash"));
const idx = __importStar(require("@openapi-generator-plus/indexed-type"));
const servers_1 = require("./process/servers");
const utils_1 = require("./process/utils");
const security_1 = require("./process/security");
const schema_1 = require("./process/schema");
const info_1 = require("./process/info");
const paths_1 = require("./process/paths");
const discriminator_1 = require("./process/schema/discriminator");
const external_docs_1 = require("./process/external-docs");
const object_1 = require("./process/schema/object");
const one_of_1 = require("./process/schema/one-of");
const utils_2 = require("./process/schema/utils");
function groupOperations(operationInfos, state) {
    const strategy = state.generator.operationGroupingStrategy();
    const groups = {};
    for (const operationInfo of operationInfos) {
        strategy(operationInfo, groups, state);
    }
    uniqueifyOperationNames(groups, state);
    return lodash_1.default.values(groups);
}
/**
 * Ensure that operation names are unique within a group.
 * This can be a problem if an API spec uses non-unique operationIds.
 */
function uniqueifyOperationNames(groups, state) {
    for (const name in groups) {
        const group = groups[name];
        const duplicateNames = findDuplicateNamesLowerCase(group.operations);
        if (duplicateNames.length > 0) {
            /* First try replacing with full names, but with path relative to this group, as we're assuming they were using operationIds
               and they weren't unique, which is how they had this problem in the first place.
             */
            for (const op of group.operations) {
                if (duplicateNames.indexOf(op.name.toLowerCase()) !== -1) {
                    op.name = state.generator.toOperationName(op.path, op.httpMethod);
                }
            }
            /* If there are any more duplicates, we'll iterate them by appending a number */
            let newDuplicateNames = findDuplicateNamesLowerCase(group.operations);
            while (newDuplicateNames.length > 0) {
                const iterations = [0].fill(1, 0, newDuplicateNames.length);
                for (const op of group.operations) {
                    const index = newDuplicateNames.indexOf(op.name.toLowerCase());
                    if (index !== -1) {
                        const iteration = iterations[index]++;
                        op.name = `${op.name}${iteration}`;
                    }
                }
                newDuplicateNames = findDuplicateNamesLowerCase(group.operations);
            }
        }
    }
}
function findDuplicateNamesLowerCase(operations) {
    const seenNames = new Set();
    const problemNames = [];
    for (const op of operations) {
        const opNameLowerCase = op.name.toLowerCase();
        if (seenNames.has(opNameLowerCase) && problemNames.indexOf(opNameLowerCase) === -1) {
            problemNames.push(opNameLowerCase);
        }
        seenNames.add(opNameLowerCase);
    }
    return problemNames;
}
function createGeneratorHelper(state) {
    return {
        addToScope: (schema, scope) => (0, utils_2.addToScope)(schema, scope, state),
        createObjectSchema: (suggestedName, scope, purpose) => (0, object_1.createObjectSchema)(suggestedName, scope, purpose, state),
        createOneOfSchema: (suggestedName, scope, purpose) => (0, one_of_1.createOneOfSchema)(suggestedName, scope, purpose, state),
        findSchema: (name, scope) => scope !== null ? scope.schemas != null ? idx.get(scope.schemas, name) : undefined : idx.get(state.schemas, name),
        scopeOf: (schema) => (0, utils_2.scopeOf)(schema, state),
    };
}
function processCodegenDocument(doc, state) {
    /* Process groups */
    for (let i = 0; i < doc.groups.length; i++) {
        const group = doc.groups[i];
        const result = processCodegenOperationGroup(group, state);
        if (!result) {
            doc.groups.splice(i, 1);
            i--;
        }
    }
    /* Process models */
    processCodegenSchemas(doc.schemas, state);
    /* Sort groups */
    doc.groups.sort((a, b) => a.name.localeCompare(b.name));
    /* Sort schemas */
    doc.schemas = idx.sortValues(doc.schemas, (a, b) => a.name.localeCompare(b.name));
    if (state.generator.postProcessDocument) {
        state.generator.postProcessDocument(doc, createGeneratorHelper(state));
    }
}
function processCodegenOperationGroup(group, state) {
    for (let i = 0; i < group.operations.length; i++) {
        const result = processCodegenOperation(group.operations[i], state);
        if (!result) {
            group.operations.splice(i, 1);
            i--;
        }
    }
    /* Remove empty groups */
    if (group.operations.length === 0) {
        return false;
    }
    /* Sort operations */
    group.operations.sort((a, b) => a.name.localeCompare(b.name));
    return true;
}
function processCodegenSchemas(models, state) {
    for (const entry of idx.iterable(models)) {
        const result = processCodegenSchema(entry[1], state);
        if (!result) {
            idx.remove(models, entry[0]);
        }
        else if ((0, types_1.isCodegenScope)(entry[1])) {
            const subModels = entry[1].schemas;
            if (subModels) {
                processCodegenSchemas(subModels, state);
                if (idx.isEmpty(subModels)) {
                    entry[1].schemas = null;
                }
            }
        }
    }
}
function processCodegenOperation(op, state) {
    if (hasNoGenerationRule(op, state)) {
        return false;
    }
    return true;
}
function processCodegenSchema(schema, state) {
    if (hasNoGenerationRule(schema, state)) {
        return false;
    }
    (0, discriminator_1.postProcessSchemaForDiscriminator)(schema);
    if (state.generator.postProcessSchema) {
        const result = state.generator.postProcessSchema(schema, createGeneratorHelper(state));
        if (result === false) {
            return false;
        }
    }
    return true;
}
function hasNoGenerationRule(ob, state) {
    const generatorType = state.generator.generatorType();
    if (generatorType === types_1.CodegenGeneratorType.SERVER) {
        return !!(ob.vendorExtensions && ob.vendorExtensions['x-no-server']);
    }
    else if (generatorType === types_1.CodegenGeneratorType.CLIENT) {
        return !!(ob.vendorExtensions && ob.vendorExtensions['x-no-client']);
    }
    else {
        return false;
    }
}
/**
 * Paths are a bit special, in that they can have a $ref and their own keys. So we need to do a special merge
 * so we can correctly traverse a chain of references and override things correctly.
 * @param pathItem
 * @param state
 * @returns
 */
function mergeReferencedPathItems(pathItem, state) {
    if (pathItem.$ref) {
        const result = Object.assign({}, pathItem);
        const referenceChainItem = mergeReferencedPathItems((0, utils_1.resolveReference)(pathItem, state), state);
        if ((0, openapi_type_guards_1.isOpenAPIV3PathItemObject)(result, state.specVersion) && (0, openapi_type_guards_1.isOpenAPIV3PathItemObject)(referenceChainItem, state.specVersion)) {
            if (!result.summary)
                result.summary = referenceChainItem.summary;
            if (!result.description)
                result.description = referenceChainItem.description;
            if (!result.trace)
                result.trace = referenceChainItem.trace;
            if (!result.servers)
                result.servers = referenceChainItem.servers;
            if (!result.parameters) {
                result.parameters = referenceChainItem.parameters;
            }
            else if (referenceChainItem.parameters) {
                /* Merge parameters */
                result.parameters = [...result.parameters, ...referenceChainItem.parameters];
            }
        }
        if ((0, openapi_type_guards_1.isOpenAPIV2PathItemObject)(result, state.specVersion) && (0, openapi_type_guards_1.isOpenAPIV2PathItemObject)(referenceChainItem, state.specVersion)) {
            if (!result.parameters) {
                result.parameters = referenceChainItem.parameters;
            }
            else if (referenceChainItem.parameters) {
                /* Merge parameters */
                result.parameters = [...result.parameters, ...referenceChainItem.parameters];
            }
        }
        if (!result.get)
            result.get = referenceChainItem.get;
        if (!result.put)
            result.put = referenceChainItem.put;
        if (!result.post)
            result.post = referenceChainItem.post;
        if (!result.delete)
            result.delete = referenceChainItem.delete;
        if (!result.options)
            result.options = referenceChainItem.options;
        if (!result.head)
            result.head = referenceChainItem.head;
        if (!result.patch)
            result.patch = referenceChainItem.patch;
        return result;
    }
    else {
        return pathItem;
    }
}
function processDocument(state) {
    var _a;
    const operations = [];
    const root = state.root;
    /* Process schemas first so we can check for duplicate names when creating new anonymous models */
    const specSchemas = (0, openapi_type_guards_1.isOpenAPIV2Document)(root) ? root.definitions : (0, openapi_type_guards_1.isOpenAPIV3Document)(root) ? (_a = root.components) === null || _a === void 0 ? void 0 : _a.schemas : undefined;
    if (specSchemas) {
        (0, schema_1.discoverCodegenSchemas)(specSchemas, state);
    }
    for (const path in root.paths) {
        const pathItem = root.paths[path];
        if (!pathItem) {
            continue;
        }
        const merged = mergeReferencedPathItems(pathItem, state);
        const pathOperations = (0, paths_1.toCodegenOperations)(path, merged, state);
        operations.push(...pathOperations);
    }
    const groups = groupOperations(operations, state);
    const doc = {
        info: (0, info_1.toCodegenInfo)(root.info),
        groups,
        schemas: state.schemas,
        servers: (0, servers_1.toCodegenServers)(root),
        securitySchemes: (0, security_1.toCodegenSecuritySchemes)(state),
        securityRequirements: root.security ? (0, security_1.toCodegenSecurityRequirements)(root.security, state) || null : null,
        externalDocs: (0, external_docs_1.toCodegenExternalDocs)(root),
    };
    processCodegenDocument(doc, state);
    return doc;
}
exports.processDocument = processDocument;
