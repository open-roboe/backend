"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isURL = exports.chainedCompare = exports.stringLiteralValueOptions = exports.toSpecVersion = void 0;
const types_1 = require("@openapi-generator-plus/types");
const openapi_type_guards_1 = require("./openapi-type-guards");
const types_2 = require("./types");
const utils_1 = require("@openapi-generator-plus/utils");
function toSpecVersion(root) {
    if ((0, openapi_type_guards_1.isOpenAPIV2Document)(root)) {
        /* https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#swagger-object */
        if (root.swagger === '2.0') {
            return types_2.CodegenSpecVersion.OpenAPIV2;
        }
        else {
            throw new Error(`Unsupported swagger specification version: ${root.swagger}`);
        }
    }
    else if ((0, openapi_type_guards_1.isOpenAPIV3Document)(root)) {
        /* As per the spec we should be able to process any specification with the major version 3.
         * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#versions
         */
        if (root.openapi.startsWith('3.') || root.openapi === '3') {
            return types_2.CodegenSpecVersion.OpenAPIV3;
        }
        else {
            throw new Error(`Unsupported OpenAPI specification version: ${root.openapi}`);
        }
    }
    else {
        throw new Error(`API specification document not recognised as Swagger or OpenAPI: ${(0, utils_1.debugStringify)(root)}`);
    }
}
exports.toSpecVersion = toSpecVersion;
function stringLiteralValueOptions(generator) {
    return {
        type: 'string',
        schemaType: types_1.CodegenSchemaType.STRING,
        nativeType: generator.toNativeType({ type: 'string', schemaType: types_1.CodegenSchemaType.STRING }),
        component: null,
        required: true,
        nullable: false,
        readOnly: false,
        writeOnly: false,
    };
}
exports.stringLiteralValueOptions = stringLiteralValueOptions;
/**
 * Chain CompareFunctions for multi-factor sorting.
 * @param compares
 */
function chainedCompare(...compares) {
    return function (a, b) {
        for (const f of compares) {
            const result = f(a, b);
            if (result !== 0) {
                return result;
            }
        }
        return 0;
    };
}
exports.chainedCompare = chainedCompare;
/**
 * Test whether the given string looks like a URL according to https://www.ietf.org/rfc/rfc1738.txt
 * <p>
 * Checks if the string starts with a valid scheme followed by a colon.
 * @param value
 * @returns
 */
function isURL(value) {
    return value.match(/^[a-zA-Z0-9+.-]+:/) !== null;
}
exports.isURL = isURL;
