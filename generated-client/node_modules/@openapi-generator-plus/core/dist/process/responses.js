"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCodegenResponses = void 0;
const types_1 = require("@openapi-generator-plus/types");
const utils_1 = require("./utils");
const idx = __importStar(require("@openapi-generator-plus/indexed-type"));
const openapi_type_guards_1 = require("../openapi-type-guards");
const examples_1 = require("./examples");
const content_1 = require("./content");
const headers_1 = require("./headers");
const vendor_extensions_1 = require("./vendor-extensions");
const media_types_1 = require("./media-types");
const schema_1 = require("./schema");
const utils_2 = require("@openapi-generator-plus/utils");
function toCodegenResponses(operation, scopeName, state) {
    const responses = operation.responses;
    if (!responses) {
        return undefined;
    }
    const result = idx.create();
    let bestCode;
    let bestResponse;
    for (const responseCodeString in responses) {
        const responseCode = responseCodeString === 'default' ? 0 : parseInt(responseCodeString, 10);
        const response = toCodegenResponse(operation, responseCode, responses[responseCodeString], false, scopeName, state);
        idx.set(result, `${responseCode}`, response);
        /* See DefaultCodegen.findMethodResponse */
        if (responseCode === 0 || Math.floor(responseCode / 100) === 2) {
            if (bestCode === undefined || responseCode < bestCode) {
                bestCode = responseCode;
                bestResponse = response;
            }
        }
    }
    if (bestCode !== undefined && bestResponse) {
        bestResponse.isDefault = true;
    }
    return idx.undefinedIfEmpty(result);
}
exports.toCodegenResponses = toCodegenResponses;
function toCodegenResponse(operation, code, response, isDefault, scopeName, state) {
    const responseContextName = (0, openapi_type_guards_1.isOpenAPIReferenceObject)(response) ? (0, utils_1.nameFromRef)(response.$ref, state) : `${scopeName}_${code}_response`;
    /* We allow preserving the original description if the usage is by reference */
    const description = (0, openapi_type_guards_1.isOpenAPIReferenceObject)(response) ? response.description : undefined;
    response = (0, utils_1.resolveReference)(response, state);
    if (code === 0) {
        code = 200;
    }
    let contents;
    if ((0, openapi_type_guards_1.isOpenAPIV2ResponseObject)(response, state.specVersion)) {
        if (response.schema) {
            /* We don't pass scopeNames to toCodegenProperty; see toCodegenParameter for rationale */
            const schemaUse = (0, schema_1.toCodegenSchemaUsage)(response.schema, state, {
                required: true,
                suggestedName: responseContextName,
                purpose: types_1.CodegenSchemaPurpose.RESPONSE,
                suggestedScope: null,
            });
            const examples = (0, examples_1.toCodegenExamples)(undefined, response.examples, undefined, schemaUse, state);
            const mediaTypes = toProduceMediaTypes(operation, state);
            if (!mediaTypes) {
                state.log(types_1.CodegenLogLevel.WARN, `Response for operation ${scopeName} has a schema but operation doesn't specify any produces media types`);
            }
            contents = mediaTypes ? mediaTypes.map(mediaType => {
                const result = Object.assign(Object.assign({ mediaType }, schemaUse), { examples: examples && examples[mediaType.mediaType] ? { default: examples[mediaType.mediaType] } : null, encoding: null });
                (0, content_1.applyCodegenContentEncoding)(result, undefined, state);
                return result;
            }) : undefined;
        }
    }
    else if ((0, openapi_type_guards_1.isOpenAPIV3ResponseObject)(response, state.specVersion)) {
        if (response.content) {
            /* We don't pass scopeNames to toCodegenProperty; see toCodegenParameter for rationale */
            contents = (0, content_1.toCodegenContentArray)(response.content, true, responseContextName, types_1.CodegenSchemaPurpose.RESPONSE, null, state);
        }
    }
    else {
        throw new Error(`Unsupported response: ${(0, utils_2.debugStringify)(response)}`);
    }
    const produces = (0, content_1.findAllContentMediaTypes)(contents);
    const defaultContent = (contents && contents.length) ? contents[0] : null;
    return {
        code,
        description: description || response.description,
        isDefault,
        contents: contents && contents.length ? contents : null,
        defaultContent,
        produces: produces || null,
        headers: (0, headers_1.toCodegenHeaders)(response.headers, state),
        vendorExtensions: (0, vendor_extensions_1.toCodegenVendorExtensions)(response),
    };
}
function toProduceMediaTypes(op, state) {
    if (op.produces) {
        return op.produces.map(mediaType => (0, media_types_1.toCodegenMediaType)(mediaType));
    }
    else {
        const doc = state.root;
        if (doc.produces) {
            return doc.produces.map(mediaType => (0, media_types_1.toCodegenMediaType)(mediaType));
        }
        else {
            return undefined;
        }
    }
}
