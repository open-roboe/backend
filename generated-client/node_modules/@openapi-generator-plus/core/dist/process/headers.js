"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCodegenHeaders = void 0;
const types_1 = require("@openapi-generator-plus/types");
const openapi_type_guards_1 = require("../openapi-type-guards");
const examples_1 = require("./examples");
const schema_1 = require("./schema");
const utils_1 = require("./utils");
const vendor_extensions_1 = require("./vendor-extensions");
function toCodegenHeaders(headers, state) {
    if (headers === undefined) {
        return null;
    }
    const result = {};
    for (const key in headers) {
        const header = toCodegenHeader(key, headers[key], state);
        result[key] = header;
    }
    if (Object.keys(result).length === 0) {
        return null;
    }
    return result;
}
exports.toCodegenHeaders = toCodegenHeaders;
function toCodegenHeader(name, header, state) {
    const headerContextName = (0, openapi_type_guards_1.isOpenAPIReferenceObject)(header) ? (0, utils_1.nameFromRef)(header.$ref, state) : name;
    header = (0, utils_1.resolveReference)(header, state);
    if ((0, openapi_type_guards_1.isOpenAPIV2HeaderObject)(header, state.specVersion)) {
        const schemaUse = (0, schema_1.toCodegenSchemaUsage)(header, state, {
            required: false,
            suggestedName: headerContextName,
            purpose: types_1.CodegenSchemaPurpose.HEADER,
            suggestedScope: null,
        });
        return Object.assign(Object.assign({ name: state.generator.toIdentifier(name), serializedName: name, description: null }, schemaUse), { required: false, nullable: false, readOnly: false, writeOnly: false, deprecated: false, collectionFormat: header.collectionFormat || null, vendorExtensions: (0, vendor_extensions_1.toCodegenVendorExtensions)(header), examples: null });
    }
    else if ((0, openapi_type_guards_1.isOpenAPIV3HeaderObject)(header, state.specVersion)) {
        const schemaUse = (0, schema_1.toCodegenSchemaUsage)(header.schema || { type: 'string' }, state, {
            required: (0, utils_1.convertToBoolean)(header.required, false),
            suggestedName: name,
            purpose: types_1.CodegenSchemaPurpose.HEADER,
            suggestedScope: null,
        });
        const examples = (0, examples_1.toCodegenExamples)(header.example, header.examples, undefined, schemaUse, state);
        return Object.assign(Object.assign({ name: state.generator.toIdentifier(name), serializedName: name }, schemaUse), { description: header.description || null, required: (0, utils_1.convertToBoolean)(header.required, false), collectionFormat: null, examples, nullable: false, readOnly: false, writeOnly: false, deprecated: (0, utils_1.convertToBoolean)(header.deprecated, false), vendorExtensions: (0, vendor_extensions_1.toCodegenVendorExtensions)(header) });
    }
    else {
        throw 'Unsupported spec version';
    }
}
