"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCodegenOperation = void 0;
const types_1 = require("@openapi-generator-plus/types");
const openapi_type_guards_1 = require("../openapi-type-guards");
const security_1 = require("./security");
const utils_1 = require("./utils");
const vendor_extensions_1 = require("./vendor-extensions");
const idx = __importStar(require("@openapi-generator-plus/indexed-type"));
const lodash_1 = __importDefault(require("lodash"));
const media_types_1 = require("./media-types");
const parameters_1 = require("./parameters");
const responses_1 = require("./responses");
const content_1 = require("./content");
const indexed_type_1 = require("@openapi-generator-plus/indexed-type");
const naming_1 = require("./schema/naming");
const external_docs_1 = require("./external-docs");
const servers_1 = require("./servers");
function toCodegenOperation(fullPath, method, operation, context, state) {
    const name = toCodegenOperationName(fullPath, method, operation, state);
    const responses = (0, responses_1.toCodegenResponses)(operation, name, state);
    const defaultResponse = responses ? idx.find(responses, r => r.isDefault) : undefined;
    let parameters;
    if (operation.parameters) {
        parameters = (0, parameters_1.toCodegenParameters)(operation.parameters, context.parameters, name, state);
    }
    else if (context.parameters) {
        parameters = idx.merge(idx.create(), context.parameters);
    }
    else {
        parameters = null;
    }
    let consumes;
    let bodyParam;
    if ((0, openapi_type_guards_1.isOpenAPIV3Operation)(operation, state.specVersion)) {
        let requestBody = operation.requestBody;
        if (requestBody) {
            const requestBodyContextName = (0, openapi_type_guards_1.isOpenAPIReferenceObject)(requestBody) ? (0, utils_1.nameFromRef)(requestBody.$ref, state) : `${name}_request`;
            requestBody = (0, utils_1.resolveReference)(requestBody, state);
            /* See toCodegenParameter for rationale about scopeNames */
            const requestBodyContents = (0, content_1.toCodegenContentArray)(requestBody.content, requestBody.required || false, requestBodyContextName, types_1.CodegenSchemaPurpose.REQUEST_BODY, null, state);
            if (!requestBodyContents.length) {
                throw new Error(`Request body contents is empty: ${fullPath}`);
            }
            consumes = (0, content_1.findAllContentMediaTypes)(requestBodyContents);
            if (!consumes) {
                throw new Error(`No contents for request body: ${fullPath}`);
            }
            const defaultContent = requestBodyContents[0];
            bodyParam = {
                name: (0, naming_1.toUniqueName)('request', undefined, parameters, state),
                serializedName: 'request',
                required: defaultContent.required,
                schema: defaultContent.schema,
                nativeType: defaultContent.nativeType,
                examples: defaultContent.examples,
                defaultValue: null,
                nullable: false,
                readOnly: false,
                writeOnly: false,
                deprecated: false,
                description: requestBody.description || null,
                collectionFormat: null,
                contents: requestBodyContents,
                defaultContent,
                consumes,
                vendorExtensions: (0, vendor_extensions_1.toCodegenVendorExtensions)(requestBody),
            };
        }
    }
    else {
        consumes = toConsumeMediaTypes(operation, state);
        /* Apply special body param properties */
        if (parameters) {
            const bodyParamEntry = idx.findEntry(parameters, p => p.in === 'body');
            if (bodyParamEntry) {
                if (!consumes) {
                    throw new Error(`Consumes not specified for operation with body parameter: ${fullPath}`);
                }
                const existingBodyParam = bodyParamEntry[1];
                const contents = consumes.map(mediaType => {
                    const result = {
                        mediaType,
                        encoding: null,
                        examples: null,
                        required: existingBodyParam.required,
                        schema: existingBodyParam.schema,
                        nativeType: existingBodyParam.nativeType,
                    };
                    (0, content_1.applyCodegenContentEncoding)(result, undefined, state);
                    return result;
                });
                if (!contents.length) {
                    throw new Error(`Request body contents is empty: ${fullPath}`);
                }
                bodyParam = {
                    name: existingBodyParam.name,
                    serializedName: existingBodyParam.serializedName,
                    description: existingBodyParam.description,
                    collectionFormat: existingBodyParam.collectionFormat,
                    vendorExtensions: existingBodyParam.vendorExtensions,
                    nullable: existingBodyParam.nullable,
                    readOnly: existingBodyParam.readOnly,
                    writeOnly: existingBodyParam.writeOnly,
                    deprecated: existingBodyParam.deprecated,
                    contents,
                    defaultContent: contents[0],
                    consumes,
                    schema: existingBodyParam.schema,
                    nativeType: existingBodyParam.nativeType,
                    defaultValue: existingBodyParam.defaultValue,
                    examples: existingBodyParam.examples,
                    required: existingBodyParam.required,
                };
                idx.remove(parameters, bodyParamEntry[0]);
            }
        }
    }
    /* Ensure parameters is null if empty, as generators rely on that */
    parameters = (0, indexed_type_1.nullIfEmpty)(parameters);
    let securityRequirements;
    if (operation.security) {
        securityRequirements = (0, security_1.toCodegenSecurityRequirements)(operation.security, state);
    }
    else if (state.root.security) {
        /* Use document-wide security requirements if the operation doesn't specify any */
        securityRequirements = (0, security_1.toCodegenSecurityRequirements)(state.root.security, state);
    }
    const queryParams = parameters ? idx.nullIfEmpty(idx.filter(parameters, p => p.isQueryParam)) : null;
    const pathParams = parameters ? idx.nullIfEmpty(idx.filter(parameters, p => p.isPathParam)) : null;
    const headerParams = parameters ? idx.nullIfEmpty(idx.filter(parameters, p => p.isHeaderParam)) : null;
    const cookieParams = parameters ? idx.nullIfEmpty(idx.filter(parameters, p => p.isCookieParam)) : null;
    const formParams = parameters ? idx.nullIfEmpty(idx.filter(parameters, p => p.isFormParam)) : null;
    /* Validate path params */
    if (pathParams) {
        for (const param of idx.allValues(pathParams)) {
            if (fullPath.indexOf(`{${param.serializedName}}`) === -1) {
                state.log(types_1.CodegenLogLevel.WARN, `${fullPath} has a path parameter "${param.serializedName}" that is not contained in the path.`);
            }
        }
    }
    const op = {
        name,
        httpMethod: method,
        path: fullPath,
        fullPath,
        returnNativeType: defaultResponse && defaultResponse.defaultContent && defaultResponse.defaultContent.nativeType || null,
        consumes: consumes || null,
        produces: responses ? toUniqueMediaTypes(idx.allValues(responses).reduce((collected, response) => response.produces ? [...collected, ...response.produces] : collected, [])) : null,
        parameters,
        queryParams,
        pathParams,
        headerParams,
        cookieParams,
        formParams,
        requestBody: bodyParam || null,
        securityRequirements: securityRequirements || null,
        defaultResponse: defaultResponse || null,
        responses: responses || null,
        deprecated: !!operation.deprecated,
        summary: operation.summary || context.summary || null,
        description: operation.description || context.description || null,
        tags: operation.tags || null,
        vendorExtensions: (0, vendor_extensions_1.mergeCodegenVendorExtensions)(context.vendorExtensions, (0, vendor_extensions_1.toCodegenVendorExtensions)(operation)),
        externalDocs: (0, external_docs_1.toCodegenExternalDocs)(operation),
        servers: (0, servers_1.toCodegenServers)(operation) || context.servers,
        hasParamExamples: parametersHaveExamples(parameters || null),
        hasQueryParamExamples: parametersHaveExamples(queryParams),
        hasPathParamExamples: parametersHaveExamples(pathParams),
        hasHeaderParamExamples: parametersHaveExamples(headerParams),
        hasCookieParamExamples: parametersHaveExamples(cookieParams),
        hasRequestBodyExamples: requestBodyHasExamples(bodyParam || null),
        hasFormParamExamples: parametersHaveExamples(formParams),
        hasResponseExamples: responsesHaveExamples(responses || null),
    };
    return op;
}
exports.toCodegenOperation = toCodegenOperation;
function toCodegenOperationName(path, method, operation, state) {
    if (operation.operationId) {
        return state.generator.toIdentifier(operation.operationId);
    }
    return state.generator.toOperationName(path, method);
}
function parametersHaveExamples(parameters) {
    if (!parameters) {
        return false;
    }
    return !!idx.find(parameters, param => { var _a; return !!((_a = param.examples) === null || _a === void 0 ? void 0 : _a.length); });
}
function requestBodyHasExamples(parameter) {
    if (!parameter || !parameter.contents) {
        return false;
    }
    return !!parameter.contents.find(c => { var _a; return !!((_a = c.examples) === null || _a === void 0 ? void 0 : _a.length); });
}
function responsesHaveExamples(responses) {
    if (!responses) {
        return false;
    }
    return !!idx.findEntry(responses, response => response.contents && response.contents.find(c => { var _a; return !!((_a = c.examples) === null || _a === void 0 ? void 0 : _a.length); }));
}
function toUniqueMediaTypes(mediaTypes) {
    return lodash_1.default.uniqWith(mediaTypes, mediaTypeEquals);
}
function mediaTypeEquals(a, b) {
    return a.mediaType === b.mediaType;
}
function toConsumeMediaTypes(op, state) {
    var _a;
    if (op.consumes) {
        return (_a = op.consumes) === null || _a === void 0 ? void 0 : _a.map(mediaType => (0, media_types_1.toCodegenMediaType)(mediaType));
    }
    else {
        const doc = state.root;
        if (doc.consumes) {
            return doc.consumes.map(mediaType => (0, media_types_1.toCodegenMediaType)(mediaType));
        }
        else {
            return undefined;
        }
    }
}
