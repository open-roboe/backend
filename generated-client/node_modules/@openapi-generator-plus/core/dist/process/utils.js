"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCodegenInitialValueOptions = exports.toCodegenLiteralValueOptions = exports.toCodegenDefaultValueOptions = exports.toDefaultValue = exports.convertToNumber = exports.convertToBoolean = exports.nameFromRef = exports.coalesce = exports.extractCodegenSchemaUsage = exports.extractCodegenSchemaInfo = exports.typeInfoToString = exports.equalCodegenTypeInfo = exports.resolveReference = void 0;
const openapi_type_guards_1 = require("../openapi-type-guards");
const types_1 = require("@openapi-generator-plus/types");
const paths_1 = require("./paths");
const utils_1 = require("./schema/utils");
/**
 * Resolve anything that may also be a ReferenceObject to the base type.
 * @param ob
 * @param state
 */
function resolveReference(ob, state) {
    const seen = new Set();
    while ((0, openapi_type_guards_1.isOpenAPIReferenceObject)(ob)) {
        if (seen.has(ob)) {
            throw new Error('Recursive $ref');
        }
        seen.add(ob);
        ob = state.$refs.get(ob.$ref);
    }
    return ob;
}
exports.resolveReference = resolveReference;
/**
 * Extract _just_ the CodegenTypeInfo properties from the source.
 */
function extractCodegenTypeOptions(source) {
    return {
        type: source.type,
        format: source.format,
        schemaType: source.schemaType,
    };
}
function extractCodegenNativeTypeUsageOptions(usage) {
    return Object.assign(Object.assign({}, extractCodegenTypeOptions(usage.schema)), { required: usage.required, nullable: usage.nullable, readOnly: usage.readOnly, writeOnly: usage.writeOnly });
}
function equalCodegenTypeInfo(a, b) {
    if ((0, types_1.isCodegenSchemaUsage)(a)) {
        a = a.schema;
    }
    if ((0, types_1.isCodegenSchemaUsage)(b)) {
        b = b.schema;
    }
    return (a.type === b.type &&
        a.format === b.format &&
        a.schemaType === b.schemaType &&
        (a.component === b.component || (!!a.component && !!b.component && a.component.nativeType.equals(b.component.nativeType))));
}
exports.equalCodegenTypeInfo = equalCodegenTypeInfo;
function typeInfoToString(a) {
    if ((0, types_1.isCodegenSchemaUsage)(a)) {
        a = a.schema;
    }
    let result = `${a.type} (`;
    if (a.format) {
        result += `format = ${a.format}, `;
    }
    result += `schemaType = ${a.schemaType}`;
    if (a.component) {
        result += `, component = ${a.component.nativeType}`;
    }
    result += ')';
    return result;
}
exports.typeInfoToString = typeInfoToString;
/**
 * Extract _just_ the CodegenSchemaUsage properties from the source.
 */
function extractCodegenSchemaInfo(source) {
    return {
        nativeType: source.nativeType,
        nullable: source.nullable,
        readOnly: source.readOnly,
        writeOnly: source.writeOnly,
        deprecated: source.deprecated,
    };
}
exports.extractCodegenSchemaInfo = extractCodegenSchemaInfo;
function extractCodegenSchemaUsage(source) {
    return Object.assign(Object.assign({}, extractCodegenSchemaInfo(source)), { required: source.required, schema: source.schema, examples: source.examples, defaultValue: source.defaultValue });
}
exports.extractCodegenSchemaUsage = extractCodegenSchemaUsage;
function coalesce(...values) {
    for (const value of values) {
        if (value !== undefined) {
            return value;
        }
    }
    return undefined;
}
exports.coalesce = coalesce;
/**
 * Convert a `$ref` into a name that could be turned into a type.
 * @param $ref
 */
function nameFromRef($ref, state) {
    const pathRef = pathPartOfRef($ref);
    const relativeRef = relativePartOfRef($ref);
    if (!relativeRef) {
        return 'Unknown';
    }
    const components = relativeRef.split('/');
    /* OpenAPI v3 schemas */
    if (components.length > 2 && components[0] === 'components' && components[1] === 'schemas') {
        return components[components.length - 1];
    }
    /* OpenAPI v2 schemas */
    if (components.length > 1 && components[0] === 'definitions') {
        return components[components.length - 1];
    }
    /* References to things in paths */
    if (components.length && components[0] === 'paths') {
        /* References to responses */
        if (components.length === 5 && components[3] === 'responses') {
            const pathItem = state.$refs.get(`${pathRef}#/paths/${components[1]}`);
            if (pathItem) {
                const operations = (0, paths_1.toCodegenOperations)(unescape(components[1]), pathItem, state);
                const operation = operations.find(op => op.httpMethod === components[2].toUpperCase());
                if (operation && operation.responses) {
                    const response = operation.responses[components[4]];
                    if (response && response.defaultContent && response.defaultContent.schema) {
                        const suggestedName = (0, utils_1.baseSuggestedNameForRelatedSchemas)(response.defaultContent.schema);
                        if (suggestedName !== null) {
                            return suggestedName;
                        }
                    }
                    if (response && response.defaultContent && response.defaultContent.nativeType) {
                        return response.defaultContent.nativeType.nativeType;
                    }
                }
            }
        }
        else if (components.length === 8 && components[3] === 'responses' && components[5] === 'content' && components[7] === 'schema') {
            const pathItem = state.$refs.get(`${pathRef}#/paths/${components[1]}`);
            if (pathItem) {
                const operations = (0, paths_1.toCodegenOperations)(unescape(components[1]), pathItem, state);
                const operation = operations.find(op => op.httpMethod === components[2].toUpperCase());
                if (operation && operation.responses) {
                    const response = operation.responses[components[4]];
                    if (response && response.contents) {
                        const content = response.contents.find(co => co.mediaType.mediaType === unescape(components[6]));
                        if (content && content.schema) {
                            const suggestedName = (0, utils_1.baseSuggestedNameForRelatedSchemas)(content.schema);
                            if (suggestedName !== null) {
                                return suggestedName;
                            }
                        }
                        if (content && content.nativeType) {
                            return content.nativeType.nativeType;
                        }
                    }
                }
            }
        }
    }
    /* Fallback */
    return components[components.length - 1];
}
exports.nameFromRef = nameFromRef;
function pathPartOfRef($ref) {
    const i = $ref.indexOf('#');
    if (i !== -1) {
        return $ref.substring(0, i);
    }
    else {
        return $ref;
    }
}
function relativePartOfRef($ref) {
    const i = $ref.indexOf('#');
    if (i !== -1) {
        $ref = $ref.substring(i + 1);
        if ($ref.startsWith('/')) {
            $ref = $ref.substring(1);
        }
        return $ref;
    }
    else {
        return null;
    }
}
function convertToBoolean(value, defaultValue) {
    if (typeof value === 'undefined' || value === null) {
        return defaultValue;
    }
    if (typeof value === 'string') {
        if (value === 'true' || value === 'yes') {
            return true;
        }
        else if (value === 'false' || value === 'no' || !value) {
            return false;
        }
        else {
            throw new Error(`Unexpected boolean string value: ${value}`);
        }
    }
    if (typeof value === 'boolean') {
        return value;
    }
    throw new Error(`Unexpected boolean value: ${value}`);
}
exports.convertToBoolean = convertToBoolean;
function convertToNumber(value) {
    if (typeof value === 'number') {
        return value;
    }
    else {
        return null;
    }
}
exports.convertToNumber = convertToNumber;
/**
 * Process a default value from the API schema into our default value type.
 * @param value
 * @param schemaUsage
 * @param state
 * @returns
 */
function toDefaultValue(value, schemaUsage, state) {
    if (value === undefined) {
        return null;
    }
    const literalValue = state.generator.toLiteral(value, toCodegenLiteralValueOptions(schemaUsage));
    if (literalValue === null) {
        state.log(types_1.CodegenLogLevel.WARN, `Cannot format literal for default value "${value}"`);
        return null;
    }
    return {
        value,
        literalValue,
    };
}
exports.toDefaultValue = toDefaultValue;
function toCodegenDefaultValueOptions(usage) {
    return Object.assign(Object.assign({}, extractCodegenNativeTypeUsageOptions(usage)), { schemaType: usage.schema.schemaType, nativeType: usage.nativeType, component: usage.schema.component });
}
exports.toCodegenDefaultValueOptions = toCodegenDefaultValueOptions;
function toCodegenLiteralValueOptions(usage) {
    return toCodegenDefaultValueOptions(usage);
}
exports.toCodegenLiteralValueOptions = toCodegenLiteralValueOptions;
function toCodegenInitialValueOptions(usage) {
    return Object.assign(Object.assign({}, toCodegenDefaultValueOptions(usage)), { defaultValue: usage.defaultValue });
}
exports.toCodegenInitialValueOptions = toCodegenInitialValueOptions;
