"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.discoverSchemasInOtherDocuments = exports.toCodegenSchemaUsage = exports.discoverCodegenSchemas = void 0;
const types_1 = require("@openapi-generator-plus/types");
const utils_1 = require("@openapi-generator-plus/utils");
const openapi_type_guards_1 = require("../../openapi-type-guards");
const examples_1 = require("../examples");
const external_docs_1 = require("../external-docs");
const utils_2 = require("../utils");
const vendor_extensions_1 = require("../vendor-extensions");
const all_of_1 = require("./all-of");
const any_of_1 = require("./any-of");
const array_1 = require("./array");
const boolean_1 = require("./boolean");
const enum_1 = require("./enum");
const map_1 = require("./map");
const naming_1 = require("./naming");
const numeric_1 = require("./numeric");
const object_1 = require("./object");
const one_of_1 = require("./one-of");
const schema_type_1 = require("./schema-type");
const string_1 = require("./string");
const usage_1 = require("./usage");
const utils_3 = require("./utils");
function discoverCodegenSchemas(specSchemas, state) {
    /* Collect defined schema names first, so no inline or external schemas can use those names */
    for (const schemaName in specSchemas) {
        (0, naming_1.usedSchemaName)([schemaName], state);
        (0, utils_3.addReservedSchemaName)(schemaName, state);
    }
    for (const schemaName in specSchemas) {
        /* We load the schema using a reference as we use references to distinguish between explicit and inline models */
        const reference = {
            $ref: (0, utils_3.refForSchemaName)(schemaName, state),
        };
        toCodegenSchemaUsage(reference, state, {
            required: true,
            suggestedName: schemaName,
            purpose: types_1.CodegenSchemaPurpose.GENERAL,
            suggestedScope: null,
        });
    }
}
exports.discoverCodegenSchemas = discoverCodegenSchemas;
function toCodegenSchemaUsage(apiSchema, state, options) {
    const $ref = (0, openapi_type_guards_1.isOpenAPIReferenceObject)(apiSchema) ? apiSchema.$ref : undefined;
    const originalApiSchema = (0, openapi_type_guards_1.isOpenAPIReferenceObject)(apiSchema) ? apiSchema : undefined;
    apiSchema = (0, utils_2.resolveReference)(apiSchema, state);
    fixApiSchema(apiSchema, state);
    const schemaObject = toCodegenSchema(apiSchema, $ref, options, state);
    const result = Object.assign(Object.assign({}, (0, utils_2.extractCodegenSchemaInfo)(schemaObject)), { required: options.required, schema: schemaObject, examples: null, defaultValue: null });
    if (originalApiSchema) {
        /* We allow some properties to be overriden on a $ref */
        const originalApiSchemaAsSchemaObject = originalApiSchema;
        if (originalApiSchemaAsSchemaObject.nullable) {
            result.nullable = true;
        }
        if (originalApiSchemaAsSchemaObject.readOnly) {
            result.readOnly = true;
        }
        if (originalApiSchemaAsSchemaObject.writeOnly) {
            result.writeOnly = true;
        }
        if (originalApiSchemaAsSchemaObject.deprecated) {
            result.deprecated = true;
        }
    }
    /* Apply the schema usage to the native type */
    result.nativeType = (0, usage_1.transformNativeTypeForUsage)(result, state);
    result.examples = apiSchema.example ? (0, examples_1.toCodegenExamples)(apiSchema.example, undefined, undefined, result, state) : null;
    result.defaultValue = (0, utils_2.toDefaultValue)(apiSchema.default, result, state);
    return result;
}
exports.toCodegenSchemaUsage = toCodegenSchemaUsage;
function toCodegenSchema(apiSchema, $ref, options, state) {
    /* Check if we've already generated this schema, and return it */
    const existing = (0, utils_3.findKnownSchema)(apiSchema, $ref, state);
    if (existing) {
        return existing;
    }
    const schemaType = (0, schema_type_1.toCodegenSchemaTypeFromApiSchema)(apiSchema);
    const { purpose, suggestedScope } = options;
    let { suggestedName } = options;
    if (typeof suggestedName === 'function') {
        suggestedName = suggestedName(schemaType);
    }
    /* Use purpose to refine the suggested name */
    suggestedName = state.generator.toSuggestedSchemaName(suggestedName, {
        purpose,
        schemaType,
    });
    const naming = supportedNamedSchema(schemaType, !!$ref, purpose, state) || options.nameRequired ? (0, naming_1.toUniqueScopedName)($ref, suggestedName, suggestedScope, apiSchema, schemaType, state) : null;
    if (naming) {
        (0, naming_1.usedSchemaName)(naming.scopedName, state);
    }
    /* Due to the recursive nature of nameFromRef, we might have actually generated a schema for us now! */
    const existingNow = (0, utils_3.findKnownSchema)(apiSchema, $ref, state);
    if (existingNow) {
        return existingNow;
    }
    let result;
    switch (schemaType) {
        case types_1.CodegenSchemaType.MAP:
            result = (0, map_1.toCodegenMapSchema)(apiSchema, naming, naming ? 'value' : suggestedName, naming ? naming.scope : suggestedScope, state);
            break;
        case types_1.CodegenSchemaType.OBJECT:
            if (!naming) {
                // naming = toUniqueScopedName($ref, suggestedName, suggestedScope, schema, state)
                throw new Error(`no name for ${(0, utils_1.debugStringify)(apiSchema)}`);
            }
            result = (0, object_1.toCodegenObjectSchema)(apiSchema, naming, state);
            break;
        case types_1.CodegenSchemaType.INTERFACE:
            throw new Error(`Cannot create an interface directly from an OpenAPI schema: ${(0, utils_1.debugStringify)(apiSchema)}`);
        case types_1.CodegenSchemaType.WRAPPER:
            throw new Error(`Cannot create a wrapper directly from an OpenAPI schema: ${(0, utils_1.debugStringify)(apiSchema)}`);
        case types_1.CodegenSchemaType.HIERARCHY:
            throw new Error(`Cannot create a hierarchy directly from an OpenAPI schema: ${(0, utils_1.debugStringify)(apiSchema)}`);
        case types_1.CodegenSchemaType.ALLOF:
            if (!naming) {
                throw new Error(`no name for ${(0, utils_1.debugStringify)(apiSchema)}`);
            }
            result = (0, all_of_1.toCodegenAllOfSchema)(apiSchema, naming, state);
            break;
        case types_1.CodegenSchemaType.ANYOF:
            if (!naming) {
                throw new Error(`no name for ${(0, utils_1.debugStringify)(apiSchema)}`);
            }
            result = (0, any_of_1.toCodegenAnyOfSchema)(apiSchema, naming, state);
            break;
        case types_1.CodegenSchemaType.ONEOF:
            if (!naming) {
                throw new Error(`no name for ${(0, utils_1.debugStringify)(apiSchema)}`);
            }
            result = (0, one_of_1.toCodegenOneOfSchema)(apiSchema, naming, state);
            break;
        case types_1.CodegenSchemaType.ARRAY:
            result = (0, array_1.toCodegenArraySchema)(apiSchema, naming, naming ? 'item' : suggestedName, naming ? naming.scope : suggestedScope, state);
            break;
        case types_1.CodegenSchemaType.ENUM:
            result = (0, enum_1.toCodegenEnumSchema)(apiSchema, naming, state);
            break;
        case types_1.CodegenSchemaType.NUMBER:
        case types_1.CodegenSchemaType.INTEGER:
            result = (0, numeric_1.toCodegenNumericSchema)(apiSchema, naming, state);
            break;
        case types_1.CodegenSchemaType.STRING:
            result = (0, string_1.toCodegenStringSchema)(apiSchema, naming, state);
            break;
        case types_1.CodegenSchemaType.BOOLEAN:
            result = (0, boolean_1.toCodegenBooleanSchema)(apiSchema, naming, state);
            break;
        case types_1.CodegenSchemaType.DATE:
        case types_1.CodegenSchemaType.DATETIME:
        case types_1.CodegenSchemaType.TIME:
        case types_1.CodegenSchemaType.BINARY: {
            if (typeof apiSchema.type !== 'string') {
                throw new Error(`Unsupported schema type "${apiSchema.type}" for property in ${(0, utils_1.debugStringify)(apiSchema)}`);
            }
            /* Generic unsupported schema support */
            const type = apiSchema.type;
            const format = apiSchema.format;
            const vendorExtensions = (0, vendor_extensions_1.toCodegenVendorExtensions)(apiSchema);
            const nativeType = state.generator.toNativeType({
                type,
                format,
                schemaType,
                vendorExtensions,
            });
            result = Object.assign(Object.assign(Object.assign({}, (0, naming_1.extractNaming)(naming)), { type, format: format || null, schemaType: (0, schema_type_1.toCodegenSchemaType)(type, format), nativeType, component: null, vendorExtensions, externalDocs: (0, external_docs_1.toCodegenExternalDocs)(apiSchema) }), (0, utils_3.extractCodegenSchemaCommon)(apiSchema, state));
            break;
        }
    }
    result = (0, utils_3.addToKnownSchemas)(apiSchema, result, naming, state);
    if (naming) {
        (0, utils_3.addToScope)(result, naming.scope, state);
    }
    return result;
}
// TODO this will be customised by the generator
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function supportedNamedSchema(schemaType, referenced, purpose, state) {
    if (schemaType === types_1.CodegenSchemaType.OBJECT ||
        schemaType === types_1.CodegenSchemaType.ENUM ||
        schemaType === types_1.CodegenSchemaType.ALLOF ||
        schemaType === types_1.CodegenSchemaType.ANYOF ||
        schemaType === types_1.CodegenSchemaType.ONEOF) {
        return true;
    }
    return false;
}
/**
 * Sometimes a schema omits the `type`, even though the specification states that it must be a `string`.
 * This method corrects for those cases where we can determine what the schema _should_ be.
 * @param apiSchema
 */
function fixApiSchema(apiSchema, state) {
    if (apiSchema.type === undefined) {
        if (apiSchema.required || apiSchema.properties || apiSchema.additionalProperties) {
            apiSchema.type = 'object';
        }
        else if (apiSchema.enum) {
            apiSchema.type = 'string';
        }
    }
    /* Some specs have the enum declared at the array level, rather than the items. The Vimeo API schema is an example.
       https://raw.githubusercontent.com/vimeo/openapi/master/api.yaml
    */
    if (apiSchema.type === 'array' && apiSchema.enum) {
        if (apiSchema.items) {
            const items = (0, utils_2.resolveReference)(apiSchema.items, state);
            if (!items.enum) {
                items.enum = apiSchema.enum;
                apiSchema.enum = undefined;
            }
        }
    }
}
/**
 * Discover schemas that match a test function that exist in documents that are referenced by our root document, but
 * which are not in our root document.
 * @param testFunc
 * @param state
 */
function discoverSchemasInOtherDocuments(testFunc, state) {
    var _a;
    const paths = state.$refs.paths();
    const values = state.$refs.values();
    const result = [];
    for (const path of paths) {
        const doc = values[path];
        if (doc === state.root) {
            /* Skip the root doc, as we're looking for schemas we haven't already discovered */
            continue;
        }
        const specSchemas = ((0, openapi_type_guards_1.isOpenAPIV2Document)(doc) ? doc.definitions : (_a = doc.components) === null || _a === void 0 ? void 0 : _a.schemas) || {};
        for (const schemaName in specSchemas) {
            const anApiSchema = (0, utils_2.resolveReference)(specSchemas[schemaName], state);
            if (testFunc(anApiSchema, state)) {
                /* We load the schema using a reference as we use references to distinguish between explicit and inline models */
                const reference = {
                    $ref: (0, utils_3.refForPathAndSchemaName)(path, doc, schemaName, state),
                };
                const discovered = toCodegenSchemaUsage(reference, state, {
                    required: true,
                    suggestedName: schemaName,
                    purpose: types_1.CodegenSchemaPurpose.GENERAL,
                    suggestedScope: null,
                });
                result.push(discovered);
            }
        }
    }
    return result;
}
exports.discoverSchemasInOtherDocuments = discoverSchemasInOtherDocuments;
