"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createOneOfSchema = exports.toCodegenOneOfSchema = void 0;
const types_1 = require("@openapi-generator-plus/types");
const _1 = require(".");
const utils_1 = require("@openapi-generator-plus/utils");
const openapi_type_guards_1 = require("../../openapi-type-guards");
const examples_1 = require("../examples");
const external_docs_1 = require("../external-docs");
const vendor_extensions_1 = require("../vendor-extensions");
const discriminator_1 = require("./discriminator");
const naming_1 = require("./naming");
const utils_2 = require("./utils");
const wrapper_1 = require("./wrapper");
function toCodegenOneOfSchema(apiSchema, naming, state) {
    const strategy = state.generator.oneOfStrategy();
    switch (strategy) {
        case types_1.CodegenOneOfStrategy.NATIVE:
            return toCodegenOneOfSchemaNative(apiSchema, naming, state);
        case types_1.CodegenOneOfStrategy.INTERFACE:
            return toCodegenOneOfSchemaInterface(apiSchema, naming, state);
    }
    throw new Error(`Unsupported oneOf strategy: ${strategy}`);
}
exports.toCodegenOneOfSchema = toCodegenOneOfSchema;
function toCodegenOneOfSchemaNative(apiSchema, naming, state) {
    const { scopedName, scope } = naming;
    const vendorExtensions = (0, vendor_extensions_1.toCodegenVendorExtensions)(apiSchema);
    const nativeType = state.generator.toNativeObjectType({
        type: 'object',
        schemaType: types_1.CodegenSchemaType.ONEOF,
        scopedName,
        vendorExtensions,
    });
    let result = Object.assign(Object.assign(Object.assign({}, (0, naming_1.extractNaming)(naming)), (0, utils_2.extractCodegenSchemaCommon)(apiSchema, state)), { discriminator: null, discriminatorValues: null, polymorphic: true, vendorExtensions, externalDocs: (0, external_docs_1.toCodegenExternalDocs)(apiSchema), nativeType, type: 'oneOf', format: null, schemaType: types_1.CodegenSchemaType.ONEOF, component: null, deprecated: false, examples: null, schemas: null, composes: [], implements: null });
    result.examples = (0, examples_1.toCodegenExamples)(apiSchema.example, undefined, undefined, result, state);
    if ((0, openapi_type_guards_1.isOpenAPIv3SchemaObject)(apiSchema, state.specVersion)) {
        result.deprecated = apiSchema.deprecated || false;
    }
    /* Must add model to knownSchemas here before we try to load other models to avoid infinite loop
       when a model references other models that in turn reference this model.
     */
    result = (0, utils_2.addToKnownSchemas)(apiSchema, result, naming, state);
    const oneOf = apiSchema.oneOf;
    const added = [];
    for (const oneOfApiSchema of oneOf) {
        const oneOfSchemaUsage = (0, _1.toCodegenSchemaUsage)(oneOfApiSchema, state, {
            purpose: types_1.CodegenSchemaPurpose.GENERAL,
            required: false,
            suggestedScope: state.generator.nativeCompositionCanBeScope() ? result : scope,
            suggestedName: (type) => `${type.toLowerCase()}_value`,
            nameRequired: state.generator.nativeComposedSchemaRequiresName(),
        });
        let oneOfSchema = oneOfSchemaUsage.schema;
        if (!(0, types_1.isCodegenObjectSchema)(oneOfSchema) && !(0, types_1.isCodegenCompositionSchema)(oneOfSchema) && state.generator.nativeComposedSchemaRequiresObjectLikeOrWrapper()) {
            /* Create a wrapper around this primitive type */
            const wrapper = (0, wrapper_1.createWrapperSchemaUsage)(`${oneOfSchema.schemaType.toLowerCase()}_value`, result, oneOfSchemaUsage, oneOfApiSchema, state).schema;
            oneOfSchema = wrapper;
        }
        result.composes.push(oneOfSchema);
        added.push([oneOfApiSchema, oneOfSchema]);
    }
    /* Process discriminator after adding composes so they can be used */
    result.discriminator = (0, discriminator_1.toCodegenSchemaDiscriminator)(apiSchema, result, state);
    if (result.discriminator) {
        for (const [addedApiSchema, addedSchema] of added) {
            if (!(0, types_1.isCodegenDiscriminatableSchema)(addedSchema)) {
                throw new Error(`oneOf "${result.name}" with discriminator references a non-discriminatable schema: ${(0, utils_1.debugStringify)(addedApiSchema)}`);
            }
            (0, discriminator_1.addToDiscriminator)(result, addedSchema, state);
        }
    }
    (0, discriminator_1.loadDiscriminatorMappings)(result, state);
    (0, discriminator_1.discoverDiscriminatorReferencesInOtherDocuments)(apiSchema, state);
    return result;
}
function toCodegenOneOfSchemaInterface(apiSchema, naming, state) {
    const { scopedName } = naming;
    const vendorExtensions = (0, vendor_extensions_1.toCodegenVendorExtensions)(apiSchema);
    const nativeType = state.generator.toNativeObjectType({
        type: 'object',
        schemaType: types_1.CodegenSchemaType.INTERFACE,
        scopedName,
        vendorExtensions,
    });
    let result = Object.assign(Object.assign(Object.assign({}, (0, naming_1.extractNaming)(naming)), (0, utils_2.extractCodegenSchemaCommon)(apiSchema, state)), { discriminator: null, discriminatorValues: null, polymorphic: true, vendorExtensions, externalDocs: (0, external_docs_1.toCodegenExternalDocs)(apiSchema), nativeType, type: 'object', format: null, schemaType: types_1.CodegenSchemaType.INTERFACE, component: null, deprecated: false, parents: null, children: null, implementation: null, implementors: null, properties: null, additionalProperties: null, examples: null, schemas: null });
    result.examples = (0, examples_1.toCodegenExamples)(apiSchema.example, undefined, undefined, result, state);
    if ((0, openapi_type_guards_1.isOpenAPIv3SchemaObject)(apiSchema, state.specVersion)) {
        result.deprecated = apiSchema.deprecated || false;
    }
    /* Must add model to knownSchemas here before we try to load other models to avoid infinite loop
       when a model references other models that in turn reference this model.
     */
    result = (0, utils_2.addToKnownSchemas)(apiSchema, result, naming, state);
    const oneOf = apiSchema.oneOf;
    const added = [];
    for (const oneOfApiSchema of oneOf) {
        const oneOfSchemaUsage = (0, _1.toCodegenSchemaUsage)(oneOfApiSchema, state, {
            purpose: types_1.CodegenSchemaPurpose.GENERAL,
            required: false,
            suggestedScope: result,
            suggestedName: type => `${type.toLowerCase()}_value`,
        });
        let oneOfSchema = oneOfSchemaUsage.schema;
        if (!(0, types_1.isCodegenObjectSchema)(oneOfSchema) && !(0, types_1.isCodegenCompositionSchema)(oneOfSchema)) {
            /* Create a wrapper around this primitive type */
            const wrapper = (0, wrapper_1.createWrapperSchemaUsage)((0, utils_2.baseSuggestedNameForRelatedSchemas)(oneOfSchema) || `${oneOfSchemaUsage.schema.schemaType.toLowerCase()}_value`, (0, openapi_type_guards_1.isOpenAPIReferenceObject)(oneOfApiSchema) ? null : result, oneOfSchemaUsage, oneOfApiSchema, state).schema;
            oneOfSchema = wrapper;
        }
        if (!(0, types_1.isCodegenObjectSchema)(oneOfSchema) && !(0, types_1.isCodegenCompositionSchema)(oneOfSchema) && !(0, types_1.isCodegenWrapperSchema)(oneOfSchema)) {
            throw new Error(`Failed to convert oneOf part to object schema: ${(0, utils_1.debugStringify)(oneOfApiSchema)}`);
        }
        (0, utils_2.addImplementor)(result, oneOfSchema);
        added.push([oneOfApiSchema, oneOfSchema]);
    }
    /* Discriminator - must come after the oneOf relationships are established */
    result.discriminator = (0, discriminator_1.toCodegenSchemaDiscriminator)(apiSchema, result, state);
    if (result.discriminator) {
        for (const [addedApiSchema, addedSchema] of added) {
            if (!(0, types_1.isCodegenDiscriminatableSchema)(addedSchema)) {
                throw new Error(`oneOf "${result.name}" with discriminator references a non-discriminatable schema: ${(0, utils_1.debugStringify)(addedApiSchema)}`);
            }
            (0, discriminator_1.addToDiscriminator)(result, addedSchema, state);
        }
    }
    (0, discriminator_1.loadDiscriminatorMappings)(result, state);
    (0, discriminator_1.discoverDiscriminatorReferencesInOtherDocuments)(apiSchema, state);
    return result;
}
function createOneOfSchema(suggestedName, scope, purpose, state) {
    suggestedName = state.generator.toSuggestedSchemaName(suggestedName, {
        purpose,
        schemaType: types_1.CodegenSchemaType.OBJECT,
    });
    const naming = (0, naming_1.toUniqueScopedName)(undefined, suggestedName, scope, undefined, types_1.CodegenSchemaType.OBJECT, state);
    const nativeType = state.generator.toNativeObjectType({
        type: 'object',
        schemaType: types_1.CodegenSchemaType.ONEOF,
        scopedName: naming.scopedName,
        vendorExtensions: null,
    });
    const result = Object.assign(Object.assign({}, (0, naming_1.extractNaming)(naming)), { description: null, title: null, discriminator: null, discriminatorValues: null, polymorphic: true, vendorExtensions: null, externalDocs: null, nativeType, type: 'oneOf', format: null, schemaType: types_1.CodegenSchemaType.ONEOF, component: null, deprecated: false, examples: null, schemas: null, nullable: false, readOnly: false, writeOnly: false, composes: [], implements: null });
    return result;
}
exports.createOneOfSchema = createOneOfSchema;
