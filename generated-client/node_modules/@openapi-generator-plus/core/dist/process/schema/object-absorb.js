"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.absorbApiSchema = exports.absorbCodegenSchema = void 0;
const types_1 = require("@openapi-generator-plus/types");
const idx = __importStar(require("@openapi-generator-plus/indexed-type"));
const openapi_type_guards_1 = require("../../openapi-type-guards");
const property_1 = require("./property");
const _1 = require(".");
const utils_1 = require("@openapi-generator-plus/utils");
const map_1 = require("./map");
const utils_2 = require("./utils");
function absorbProperties(otherProperties, schema, options) {
    for (const property of idx.allValues(otherProperties)) {
        const newProperty = Object.assign({}, property);
        if (options.makePropertiesOptional) {
            newProperty.required = false;
        }
        if (!schema.properties) {
            schema.properties = idx.create();
        }
        idx.set(schema.properties, newProperty.serializedName, newProperty);
    }
}
function absorbCodegenSchemas(schemas, target) {
    for (const schema of idx.allValues(schemas)) {
        if (!target.schemas) {
            target.schemas = idx.create();
        }
        idx.set(target.schemas, schema.name, schema);
    }
}
function absorbCodegenSchema(schema, target, options = {}) {
    if (schema.parents) {
        for (const aParent of schema.parents) {
            absorbCodegenSchema(aParent, target, options);
        }
    }
    if (schema.properties) {
        absorbProperties(schema.properties, target, { makePropertiesOptional: options.makePropertiesOptional });
    }
    if (schema.additionalProperties) {
        if (target.additionalProperties) {
            throw new Error(`Cannot absorb schema as the target already has additionalProperties: ${(0, utils_1.debugStringify)(schema)}`);
        }
        target.additionalProperties = schema.additionalProperties;
    }
    if (options.includeNestedSchemas && schema.schemas) {
        absorbCodegenSchemas(schema.schemas, target);
    }
}
exports.absorbCodegenSchema = absorbCodegenSchema;
function absorbApiSchema(apiSchema, target, scope, state) {
    if (!(0, openapi_type_guards_1.isOpenAPIReferenceObject)(apiSchema)) {
        /*
            If the other schema is inline, and we can just absorb its properties and any sub-schemas it creates,
            then we do. We absorb the sub-schemas it creates by passing this model as to scope to toCodegenProperties.

            This will not work if the inline schema is not an object schema, or is an allOf, oneOf, anyOf etc, in which
            case we fall back to using toCodegenSchemaUsage.
            */
        let absorbed = false;
        const otherProperties = (0, property_1.toCodegenProperties)(apiSchema, target, state);
        if (otherProperties) {
            absorbProperties(otherProperties, target, {});
            absorbed = true;
        }
        if (apiSchema.additionalProperties) {
            if (target.additionalProperties) {
                throw new Error(`Cannot absorb schema as the target already has additionalProperties: ${(0, utils_1.debugStringify)(apiSchema)}`);
            }
            try {
                const mapSchema = (0, map_1.toCodegenMapSchema)(apiSchema, null, 'value', target, state);
                target.additionalProperties = mapSchema;
                absorbed = true;
            }
            catch (error) {
                state.log(types_1.CodegenLogLevel.WARN, `Failed to absorb additional property schema into ${target.name}: ${error.message}`);
            }
        }
        if (absorbed) {
            /* We return undefined as we left nothing that needs to be handled */
            return undefined;
        }
    }
    const schemaUsage = (0, _1.toCodegenSchemaUsage)(apiSchema, state, {
        required: true,
        suggestedName: (0, utils_2.baseSuggestedNameForRelatedSchemas)(target),
        purpose: types_1.CodegenSchemaPurpose.GENERAL,
        suggestedScope: scope,
    });
    const schema = schemaUsage.schema;
    if ((0, types_1.isCodegenMapSchema)(schema)) {
        if (target.additionalProperties) {
            throw new Error(`Cannot absorb schema as the target already has additionalProperties: ${(0, utils_1.debugStringify)(schema)}`);
        }
        target.additionalProperties = schema;
    }
    else if ((0, types_1.isCodegenObjectLikeSchema)(schema)) {
        /* We only include nested schemas if the schema being observed won't actually exist to contain its nested schemas itself */
        absorbCodegenSchema(schema, target, { includeNestedSchemas: false });
    }
    else {
        throw new Error(`Cannot absorb schema as it isn't an object: ${(0, utils_1.debugStringify)(schema)}`);
    }
    return schema;
}
exports.absorbApiSchema = absorbApiSchema;
