"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCodegenProperty = exports.toCodegenPropertySummary = exports.addCodegenProperty = exports.toRequiredPropertyNames = exports.toCodegenProperties = void 0;
const types_1 = require("@openapi-generator-plus/types");
const utils_1 = require("../utils");
const idx = __importStar(require("@openapi-generator-plus/indexed-type"));
const naming_1 = require("./naming");
const openapi_type_guards_1 = require("../../openapi-type-guards");
const _1 = require(".");
const vendor_extensions_1 = require("../vendor-extensions");
const usage_1 = require("./usage");
const utils_2 = require("@openapi-generator-plus/utils");
function toCodegenProperties(apiSchema, scope, state) {
    if (typeof apiSchema.properties !== 'object') {
        return undefined;
    }
    const requiredPropertyNames = toRequiredPropertyNames(apiSchema);
    const properties = idx.create();
    for (const propertyName in apiSchema.properties) {
        const requiredIndex = requiredPropertyNames.indexOf(propertyName);
        const required = requiredIndex !== -1;
        const propertySchema = apiSchema.properties[propertyName];
        const property = toCodegenProperty(propertyName, propertySchema, required, scope, state);
        addCodegenProperty(properties, property, state);
        if (required) {
            requiredPropertyNames.splice(requiredIndex, 1);
        }
    }
    if (requiredPropertyNames.length > 0) {
        state.log(types_1.CodegenLogLevel.WARN, `Required properties [${requiredPropertyNames.join(', ')}] missing from properties: ${(0, utils_2.debugStringify)(apiSchema)}`);
    }
    return idx.undefinedIfEmpty(properties);
}
exports.toCodegenProperties = toCodegenProperties;
function toRequiredPropertyNames(apiSchema) {
    return typeof apiSchema.required === 'object' ? [...apiSchema.required] : [];
}
exports.toRequiredPropertyNames = toRequiredPropertyNames;
/**
 * Add the given property to the given set of object properties. Ensures that the property name is unique within the set of properties.
 * Note that property names are unique in the spec, but may not be when converted to identifiers for the current generator.
 * @param properties the object properties
 * @param property the property to add
 * @param state
 * @returns
 */
function addCodegenProperty(properties, property, state) {
    const uniquePropertyName = (0, naming_1.toUniqueName)(property.name, undefined, properties, state);
    property.name = uniquePropertyName;
    if (idx.has(properties, property.serializedName)) {
        throw new Error(`properties already includes "${property.serializedName}" in ${properties}`);
    }
    idx.set(properties, property.serializedName, property);
    return property;
}
exports.addCodegenProperty = addCodegenProperty;
function toCodegenProperty(name, apiSchema, required, scope, state) {
    /* We allow preserving the original description if the usage is by reference */
    const description = (0, openapi_type_guards_1.isOpenAPIReferenceObject)(apiSchema) ? apiSchema.description : undefined;
    const schemaUsage = (0, _1.toCodegenSchemaUsage)(apiSchema, state, {
        required,
        suggestedName: name,
        purpose: types_1.CodegenSchemaPurpose.PROPERTY,
        suggestedScope: scope,
    });
    return Object.assign(Object.assign({}, schemaUsage), { name: state.generator.toIdentifier(name), serializedName: name, description: description || schemaUsage.schema.description || null, initialValue: state.generator.initialValue((0, utils_1.toCodegenInitialValueOptions)(schemaUsage)), vendorExtensions: (0, vendor_extensions_1.toCodegenVendorExtensions)(apiSchema), discriminators: null });
}
function toCodegenPropertySummary(name, apiSchema, required) {
    return {
        name,
        type: apiSchema.type,
        format: apiSchema.format,
        readOnly: (0, utils_1.convertToBoolean)(apiSchema.readOnly, false),
        writeOnly: (0, utils_1.convertToBoolean)(apiSchema.writeOnly, false),
        nullable: (0, utils_1.convertToBoolean)(apiSchema.nullable, false),
        required,
    };
}
exports.toCodegenPropertySummary = toCodegenPropertySummary;
function createCodegenProperty(name, schemaUsage, state) {
    const property = Object.assign(Object.assign({ name: state.generator.toIdentifier(name), serializedName: name, description: null }, (0, utils_1.extractCodegenSchemaUsage)(schemaUsage)), { initialValue: state.generator.initialValue((0, utils_1.toCodegenInitialValueOptions)(schemaUsage)), vendorExtensions: null, discriminators: null });
    property.nativeType = (0, usage_1.transformNativeTypeForUsage)(property, state);
    return property;
}
exports.createCodegenProperty = createCodegenProperty;
