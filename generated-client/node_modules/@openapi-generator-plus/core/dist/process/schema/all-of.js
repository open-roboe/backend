"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCodegenAllOfSchema = void 0;
const types_1 = require("@openapi-generator-plus/types");
const _1 = require(".");
const utils_1 = require("@openapi-generator-plus/utils");
const openapi_type_guards_1 = require("../../openapi-type-guards");
const examples_1 = require("../examples");
const external_docs_1 = require("../external-docs");
const utils_2 = require("../utils");
const vendor_extensions_1 = require("../vendor-extensions");
const discriminator_1 = require("./discriminator");
const interface_1 = require("./interface");
const naming_1 = require("./naming");
const object_absorb_1 = require("./object-absorb");
const utils_3 = require("./utils");
const property_1 = require("./property");
function toCodegenAllOfSchema(apiSchema, naming, state) {
    const strategy = state.generator.allOfStrategy();
    switch (strategy) {
        case types_1.CodegenAllOfStrategy.NATIVE:
            return toCodegenAllOfSchemaNative(apiSchema, naming, state);
        case types_1.CodegenAllOfStrategy.OBJECT:
        case types_1.CodegenAllOfStrategy.HIERARCHY:
            return toCodegenAllOfSchemaObject(apiSchema, naming, state);
    }
    throw new Error(`Unsupported allOf strategy: ${strategy}`);
}
exports.toCodegenAllOfSchema = toCodegenAllOfSchema;
function toCodegenAllOfSchemaNative(apiSchema, naming, state) {
    const { scopedName, scope } = naming;
    const vendorExtensions = (0, vendor_extensions_1.toCodegenVendorExtensions)(apiSchema);
    const nativeType = state.generator.toNativeObjectType({
        type: 'object',
        schemaType: types_1.CodegenSchemaType.ALLOF,
        scopedName,
        vendorExtensions,
    });
    let result = Object.assign(Object.assign(Object.assign({}, (0, naming_1.extractNaming)(naming)), (0, utils_3.extractCodegenSchemaCommon)(apiSchema, state)), { discriminator: null, discriminatorValues: null, polymorphic: false, vendorExtensions, externalDocs: (0, external_docs_1.toCodegenExternalDocs)(apiSchema), nativeType, type: 'allOf', format: null, schemaType: types_1.CodegenSchemaType.ALLOF, component: null, deprecated: false, examples: null, schemas: null, composes: [], implements: null });
    result.examples = (0, examples_1.toCodegenExamples)(apiSchema.example, undefined, undefined, result, state);
    if ((0, openapi_type_guards_1.isOpenAPIv3SchemaObject)(apiSchema, state.specVersion)) {
        result.deprecated = apiSchema.deprecated || false;
    }
    /* Must add model to knownSchemas here before we try to load other models to avoid infinite loop
       when a model references other models that in turn reference this model.
     */
    result = (0, utils_3.addToKnownSchemas)(apiSchema, result, naming, state);
    const allOf = apiSchema.allOf;
    for (const allOfApiSchema of allOf) {
        const allOfSchema = (0, _1.toCodegenSchemaUsage)(allOfApiSchema, state, {
            purpose: types_1.CodegenSchemaPurpose.GENERAL,
            required: false,
            suggestedScope: state.generator.nativeCompositionCanBeScope() ? result : scope,
            suggestedName: 'content',
            nameRequired: state.generator.nativeComposedSchemaRequiresName(),
        }).schema;
        if (!(0, types_1.isCodegenObjectSchema)(allOfSchema) && !(0, types_1.isCodegenInterfaceSchema)(allOfSchema) && !(0, types_1.isCodegenAllOfSchema)(allOfSchema)) {
            throw new Error(`allOf "${result.name}" references a non-object (${allOfSchema.schemaType}) schema: ${(0, utils_1.debugStringify)(allOfApiSchema)}`);
        }
        result.composes.push(allOfSchema);
        (0, discriminator_1.addToAnyDiscriminators)(allOfSchema, result, state);
    }
    result.discriminator = (0, discriminator_1.toCodegenSchemaDiscriminator)(apiSchema, result, state);
    if (result.discriminator) {
        result.polymorphic = true;
    }
    (0, discriminator_1.loadDiscriminatorMappings)(result, state);
    (0, discriminator_1.discoverDiscriminatorReferencesInOtherDocuments)(apiSchema, state);
    return result;
}
var SchemaApproach;
(function (SchemaApproach) {
    /** Use inheritance */
    SchemaApproach[SchemaApproach["PARENT"] = 0] = "PARENT";
    /** Absorb the schema and use interface conformance */
    SchemaApproach[SchemaApproach["ABSORB_WITH_INTERFACE"] = 1] = "ABSORB_WITH_INTERFACE";
    /** Absorb the schema with no interface conformance */
    SchemaApproach[SchemaApproach["ABSORB_NO_INTERFACE"] = 2] = "ABSORB_NO_INTERFACE";
})(SchemaApproach || (SchemaApproach = {}));
function toCodegenAllOfSchemaObject(apiSchema, naming, state) {
    const { scopedName, scope } = naming;
    const vendorExtensions = (0, vendor_extensions_1.toCodegenVendorExtensions)(apiSchema);
    const nativeType = state.generator.toNativeObjectType({
        type: 'object',
        schemaType: types_1.CodegenSchemaType.OBJECT,
        scopedName,
        vendorExtensions,
    });
    let result = Object.assign(Object.assign(Object.assign({}, (0, naming_1.extractNaming)(naming)), (0, utils_3.extractCodegenSchemaCommon)(apiSchema, state)), { abstract: false, discriminator: null, discriminatorValues: null, polymorphic: false, vendorExtensions, externalDocs: (0, external_docs_1.toCodegenExternalDocs)(apiSchema), nativeType, type: 'object', format: null, schemaType: types_1.CodegenSchemaType.OBJECT, component: null, deprecated: false, additionalProperties: null, properties: null, examples: null, children: null, interface: null, implements: null, parents: null, schemas: null });
    result.examples = (0, examples_1.toCodegenExamples)(apiSchema.example, undefined, undefined, result, state);
    if ((0, openapi_type_guards_1.isOpenAPIv3SchemaObject)(apiSchema, state.specVersion)) {
        result.deprecated = apiSchema.deprecated || false;
    }
    /* Must add model to knownSchemas here before we try to load other models to avoid infinite loop
       when a model references other models that in turn reference this model.
     */
    result = (0, utils_3.addToKnownSchemas)(apiSchema, result, naming, state);
    /* Create a discriminator, if appropriate, removing the discriminator property from the schema's
    properties.
    */
    result.discriminator = (0, discriminator_1.toCodegenSchemaDiscriminator)(apiSchema, result, state);
    if (result.discriminator) {
        result.polymorphic = true;
    }
    /* Handle the reference schemas, either using inheritance or interface conformance */
    const allOf = apiSchema.allOf;
    for (const { apiSchema: allOfApiSchema, approach } of classifyAllOfSchemas(allOf, state)) {
        if (approach === SchemaApproach.PARENT) {
            const parentSchema = (0, _1.toCodegenSchemaUsage)(allOfApiSchema, state, {
                required: true,
                suggestedName: `${result.name}_parent`,
                purpose: types_1.CodegenSchemaPurpose.GENERAL,
                suggestedScope: scope,
            }).schema;
            if ((0, types_1.isCodegenObjectSchema)(parentSchema)) {
                (0, utils_3.addChildObjectSchema)(parentSchema, result);
            }
            else if ((0, types_1.isCodegenInterfaceSchema)(parentSchema)) {
                const parentImplementation = (0, interface_1.toCodegenInterfaceImplementationSchema)(parentSchema, { allowAbstract: true }, state);
                if (parentImplementation) {
                    (0, utils_3.addChildObjectSchema)(parentImplementation, result);
                }
                else {
                    /* If we can't create an implementation containing all of the parent's properties, we must absorb and have the properties ourselves */
                    (0, object_absorb_1.absorbCodegenSchema)(parentSchema, result);
                    (0, utils_3.addImplementor)(parentSchema, result);
                }
            }
            else {
                throw new Error(`allOf "${result.name}" references a non-object-like schema: ${parentSchema.schemaType}`);
            }
            /* Add discriminator values */
            (0, discriminator_1.addToAnyDiscriminators)(parentSchema, result, state);
        }
        else if (approach === SchemaApproach.ABSORB_WITH_INTERFACE || approach === SchemaApproach.ABSORB_NO_INTERFACE) {
            /* We must absorb the schema from the others, and then indicate that we conform to them */
            const allOfSchema = (0, object_absorb_1.absorbApiSchema)(allOfApiSchema, result, scope, state);
            if (!allOfSchema) {
                continue;
            }
            if (approach === SchemaApproach.ABSORB_WITH_INTERFACE) {
                /* Make sure there's an interface schema to use */
                const interfaceSchema = (0, types_1.isCodegenObjectSchema)(allOfSchema) || (0, types_1.isCodegenHierarchySchema)(allOfSchema) ? (0, interface_1.toCodegenInterfaceSchema)(allOfSchema, scope, state) : allOfSchema;
                if ((0, types_1.isCodegenInterfaceSchema)(interfaceSchema)) {
                    (0, utils_3.addImplementor)(interfaceSchema, result);
                }
            }
            (0, discriminator_1.addToAnyDiscriminators)(allOfSchema, result, state);
            if ((0, types_1.isCodegenHierarchySchema)(allOfSchema)) {
                /* Hierarchy schemas discover their members when we find them including the hierarchy in an allOf here */
                allOfSchema.composes.push(result);
            }
        }
        else {
            throw new Error(`Unsupported schema approach: ${approach}`);
        }
    }
    (0, discriminator_1.loadDiscriminatorMappings)(result, state);
    (0, discriminator_1.discoverDiscriminatorReferencesInOtherDocuments)(apiSchema, state);
    return result;
}
/**
 * Classify each of the allOf schemas according to the approach that we should use to model them as object
 * relationships.
 * @param allOf the allOf schemas
 * @param state
 * @returns
 */
function classifyAllOfSchemas(allOf, state) {
    if (!checkObjectSchemaCompatibility(allOf, state)) {
        /* The schemas are not compatible for inheritance or interface compatibility */
        return allOf.map(apiSchema => ({
            apiSchema,
            approach: SchemaApproach.ABSORB_NO_INTERFACE,
        }));
    }
    if (state.generator.supportsInheritance()) {
        /* An allOf does not imply hierarchy (https://swagger.io/specification/#composition-and-inheritance-polymorphism)
           but we still prefer to use parent/child relationships to reduce the duplication of code.
         */
        const referenceSchemas = allOf.filter(openapi_type_guards_1.isOpenAPIReferenceObject);
        if (referenceSchemas.length === 1 || state.generator.supportsMultipleInheritance()) {
            /* Use parent/child relationships */
            return allOf.map(apiSchema => ({
                apiSchema,
                approach: (0, openapi_type_guards_1.isOpenAPIReferenceObject)(apiSchema) ? SchemaApproach.PARENT : SchemaApproach.ABSORB_WITH_INTERFACE,
            }));
        }
        /* A discriminator _does_ imply hierarchy (https://swagger.io/specification/#composition-and-inheritance-polymorphism)
           so if we can't use parent/child relationships above because there are too many possible parents, then we
           check if only one of those schemas is a discriminator hierarchy and we choose that as the parent.
         */
        const discriminatorSchemas = referenceSchemas.filter(schema => hasDiscriminator(schema, state));
        if (discriminatorSchemas.length === 1) {
            /* Use parent/child relationship with just the discriminator schema */
            return allOf.map(apiSchema => ({
                apiSchema,
                approach: apiSchema === discriminatorSchemas[0] ? SchemaApproach.PARENT : SchemaApproach.ABSORB_WITH_INTERFACE,
            }));
        }
    }
    /* If we can't find any inheritance possibilties we just absorb all of the schemas */
    return allOf.map(apiSchema => ({
        apiSchema,
        approach: SchemaApproach.ABSORB_WITH_INTERFACE,
    }));
}
/**
 * Check that the properties of the schemas are compatible with each other, otherwise we cannot use inheritance
 * as languages do not allow inheritance with incompatible property types.
 * <p>
 * Note we check that reference schema properties are compatible with each other and with our non-reference schemas,
 * as non-reference (inline) schemas are not generated as objects in the output and can therefore override
 * each other.
 *
 * @param allOf
 * @param state
 * @returns
 */
function checkObjectSchemaCompatibility(allOf, state, allOfSummary) {
    if (!allOfSummary) {
        allOfSummary = {
            properties: {},
            discriminators: [],
            schemas: [],
            referenceSchemas: [],
            inlineSchemas: [],
        };
    }
    for (let apiSchema of allOf) {
        let referenceSchema = false;
        if ((0, openapi_type_guards_1.isOpenAPIReferenceObject)(apiSchema)) {
            apiSchema = (0, utils_2.resolveReference)(apiSchema, state);
            referenceSchema = true;
        }
        allOfSummary.schemas.push(apiSchema);
        if (referenceSchema) {
            allOfSummary.referenceSchemas.push(apiSchema);
        }
        else {
            allOfSummary.inlineSchemas.push(apiSchema);
        }
        if (apiSchema.discriminator) {
            allOfSummary.discriminators.push(apiSchema.discriminator.propertyName);
        }
        if (apiSchema.allOf) {
            if (!checkObjectSchemaCompatibility(apiSchema.allOf, state, allOfSummary)) {
                return false;
            }
        }
        if (!apiSchema.properties) {
            continue;
        }
        for (const apiPropertyName of Object.keys(apiSchema.properties)) {
            let apiProperty = apiSchema.properties[apiPropertyName];
            if ((0, openapi_type_guards_1.isOpenAPIReferenceObject)(apiProperty)) {
                apiProperty = (0, utils_2.resolveReference)(apiProperty, state);
            }
            if (!allOfSummary.properties[apiPropertyName]) {
                /* We're only concerned about compatibility with properties in referenced schemas, as they are
                   the only ones that may be turned into objects in the target language.
                 */
                if (referenceSchema) {
                    const required = (0, property_1.toRequiredPropertyNames)(apiSchema).indexOf(apiPropertyName) !== -1;
                    allOfSummary.properties[apiPropertyName] = { schema: apiProperty, required };
                }
            }
            else {
                /* Check compatibility */
                const knownProperty = allOfSummary.properties[apiPropertyName];
                const required = (0, property_1.toRequiredPropertyNames)(apiSchema).indexOf(apiPropertyName) !== -1;
                if (!checkPropertyCompatibility((0, property_1.toCodegenPropertySummary)(apiPropertyName, knownProperty.schema, knownProperty.required), (0, property_1.toCodegenPropertySummary)(apiPropertyName, apiProperty, required), state)) {
                    return false;
                }
            }
        }
    }
    /* There may still be incompatibilities in the schemas for the generator's target, so we give the generator an opportunity to check. */
    return state.generator.checkAllOfInheritanceCompatibility(allOfSummary);
}
/**
 * Check that two property schemas are compatible so that one can override the other in an
 * inheritance hierarchy.
 * @param parentProp
 * @param childProp
 * @returns
 */
function checkPropertyCompatibility(parentProp, childProp, state) {
    return state.generator.checkPropertyCompatibility(parentProp, childProp);
}
function hasDiscriminator(apiSchema, state) {
    apiSchema = (0, utils_2.resolveReference)(apiSchema, state);
    if (apiSchema.discriminator) {
        return true;
    }
    if (apiSchema.allOf) {
        for (const allOfApiSchema of apiSchema.allOf) {
            if (hasDiscriminator(allOfApiSchema, state)) {
                return true;
            }
        }
    }
    return false;
}
