"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCodegenAnyOfSchema = void 0;
const types_1 = require("@openapi-generator-plus/types");
const _1 = require(".");
const utils_1 = require("@openapi-generator-plus/utils");
const openapi_type_guards_1 = require("../../openapi-type-guards");
const examples_1 = require("../examples");
const external_docs_1 = require("../external-docs");
const vendor_extensions_1 = require("../vendor-extensions");
const discriminator_1 = require("./discriminator");
const interface_1 = require("./interface");
const naming_1 = require("./naming");
const object_absorb_1 = require("./object-absorb");
const utils_2 = require("./utils");
const wrapper_1 = require("./wrapper");
function toCodegenAnyOfSchema(apiSchema, naming, state) {
    const strategy = state.generator.anyOfStrategy();
    switch (strategy) {
        case types_1.CodegenAnyOfStrategy.NATIVE:
            return toCodegenAnyOfSchemaNative(apiSchema, naming, state);
        case types_1.CodegenAnyOfStrategy.OBJECT:
            return toCodegenAnyOfSchemaObject(apiSchema, naming, state);
    }
    throw new Error(`Unsupported anyOf strategy: ${strategy}`);
}
exports.toCodegenAnyOfSchema = toCodegenAnyOfSchema;
function toCodegenAnyOfSchemaNative(apiSchema, naming, state) {
    const { scopedName, scope } = naming;
    const vendorExtensions = (0, vendor_extensions_1.toCodegenVendorExtensions)(apiSchema);
    const nativeType = state.generator.toNativeObjectType({
        type: apiSchema.type,
        schemaType: types_1.CodegenSchemaType.ANYOF,
        scopedName,
        vendorExtensions,
    });
    let result = Object.assign(Object.assign(Object.assign({}, (0, naming_1.extractNaming)(naming)), (0, utils_2.extractCodegenSchemaCommon)(apiSchema, state)), { discriminator: null, discriminatorValues: null, polymorphic: true, vendorExtensions, externalDocs: (0, external_docs_1.toCodegenExternalDocs)(apiSchema), nativeType, type: 'anyOf', format: null, schemaType: types_1.CodegenSchemaType.ANYOF, component: null, deprecated: false, examples: null, schemas: null, composes: [], implements: null });
    result.examples = (0, examples_1.toCodegenExamples)(apiSchema.example, undefined, undefined, result, state);
    if ((0, openapi_type_guards_1.isOpenAPIv3SchemaObject)(apiSchema, state.specVersion)) {
        result.deprecated = apiSchema.deprecated || false;
    }
    /* Must add model to knownSchemas here before we try to load other models to avoid infinite loop
       when a model references other models that in turn reference this model.
     */
    result = (0, utils_2.addToKnownSchemas)(apiSchema, result, naming, state);
    /* We bundle all of the properties together into this model and turn the subModels into interfaces */
    const anyOf = apiSchema.anyOf;
    const added = [];
    for (const anyOfApiSchema of anyOf) {
        const anyOfSchemaUsage = (0, _1.toCodegenSchemaUsage)(anyOfApiSchema, state, {
            purpose: types_1.CodegenSchemaPurpose.GENERAL,
            required: false,
            suggestedScope: state.generator.nativeCompositionCanBeScope() ? result : scope,
            suggestedName: (type) => `${type.toLowerCase()}_value`,
            nameRequired: state.generator.nativeComposedSchemaRequiresName(),
        });
        let anyOfSchema = anyOfSchemaUsage.schema;
        if (!(0, types_1.isCodegenObjectSchema)(anyOfSchema) && !(0, types_1.isCodegenCompositionSchema)(anyOfSchema) && state.generator.nativeComposedSchemaRequiresObjectLikeOrWrapper()) {
            /* Create a wrapper around this primitive type */
            const wrapper = (0, wrapper_1.createWrapperSchemaUsage)(`${anyOfSchema.type}_value`, result, anyOfSchemaUsage, anyOfApiSchema, state).schema;
            anyOfSchema = wrapper;
        }
        result.composes.push(anyOfSchema);
        added.push([anyOfApiSchema, anyOfSchema]);
    }
    /* Process discriminator after adding composes so they can be used */
    result.discriminator = (0, discriminator_1.toCodegenSchemaDiscriminator)(apiSchema, result, state);
    if (result.discriminator) {
        for (const [addedApiSchema, addedSchema] of added) {
            if (!(0, types_1.isCodegenDiscriminatableSchema)(addedSchema)) {
                throw new Error(`anyOf "${result.name}" with discriminator references a non-discriminatable schema: ${(0, utils_1.debugStringify)(addedApiSchema)}`);
            }
            (0, discriminator_1.addToDiscriminator)(result, addedSchema, state);
        }
    }
    (0, discriminator_1.loadDiscriminatorMappings)(result, state);
    (0, discriminator_1.discoverDiscriminatorReferencesInOtherDocuments)(apiSchema, state);
    return result;
}
function toCodegenAnyOfSchemaObject(apiSchema, naming, state) {
    const { scopedName, scope } = naming;
    const vendorExtensions = (0, vendor_extensions_1.toCodegenVendorExtensions)(apiSchema);
    const nativeType = state.generator.toNativeObjectType({
        type: 'object',
        schemaType: types_1.CodegenSchemaType.OBJECT,
        scopedName,
        vendorExtensions,
    });
    let result = Object.assign(Object.assign(Object.assign({}, (0, naming_1.extractNaming)(naming)), (0, utils_2.extractCodegenSchemaCommon)(apiSchema, state)), { abstract: false, discriminator: null, discriminatorValues: null, polymorphic: true, vendorExtensions, externalDocs: (0, external_docs_1.toCodegenExternalDocs)(apiSchema), nativeType, type: 'object', format: null, schemaType: types_1.CodegenSchemaType.OBJECT, component: null, deprecated: false, additionalProperties: null, properties: null, examples: null, children: null, interface: null, implements: null, parents: null, schemas: null });
    result.examples = (0, examples_1.toCodegenExamples)(apiSchema.example, undefined, undefined, result, state);
    if ((0, openapi_type_guards_1.isOpenAPIv3SchemaObject)(apiSchema, state.specVersion)) {
        result.deprecated = apiSchema.deprecated || false;
    }
    /* Must add model to knownSchemas here before we try to load other models to avoid infinite loop
       when a model references other models that in turn reference this model.
     */
    result = (0, utils_2.addToKnownSchemas)(apiSchema, result, naming, state);
    const anyOf = apiSchema.anyOf;
    const added = [];
    /* Absorb models and use interface conformance */
    for (const anyOfApiSchema of anyOf) {
        /* We must absorb the schema from the others, and then indicate that we conform to them */
        const anyOfSchema = (0, _1.toCodegenSchemaUsage)(anyOfApiSchema, state, {
            required: true,
            suggestedName: `${result.name}_submodel`,
            purpose: types_1.CodegenSchemaPurpose.GENERAL,
            suggestedScope: result,
        }).schema;
        if (!(0, types_1.isCodegenObjectSchema)(anyOfSchema)) {
            // TODO
            throw new Error(`Non-object schema not yet supported in anyOf: ${(0, utils_1.debugStringify)(anyOfApiSchema)}`);
        }
        (0, object_absorb_1.absorbCodegenSchema)(anyOfSchema, result, { includeNestedSchemas: false, makePropertiesOptional: true });
        /* Make sure there's an interface schema to use */
        const interfaceSchema = (0, interface_1.toCodegenInterfaceSchema)(anyOfSchema, scope, state);
        (0, utils_2.addImplementor)(interfaceSchema, result);
        added.push([anyOfApiSchema, interfaceSchema]);
    }
    /* Process discriminator after adding composes so they can be used */
    result.discriminator = (0, discriminator_1.toCodegenSchemaDiscriminator)(apiSchema, result, state);
    if (result.discriminator) {
        for (const [addedApiSchema, addedSchema] of added) {
            if (!(0, types_1.isCodegenDiscriminatableSchema)(addedSchema)) {
                throw new Error(`anyOf "${result.name}" with discriminator references a non-discriminatable schema: ${(0, utils_1.debugStringify)(addedApiSchema)}`);
            }
            (0, discriminator_1.addToDiscriminator)(result, addedSchema, state);
        }
    }
    (0, discriminator_1.loadDiscriminatorMappings)(result, state);
    (0, discriminator_1.discoverDiscriminatorReferencesInOtherDocuments)(apiSchema, state);
    return result;
}
