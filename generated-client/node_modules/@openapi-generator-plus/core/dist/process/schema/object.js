"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createObjectSchema = exports.toCodegenObjectSchema = void 0;
const types_1 = require("@openapi-generator-plus/types");
const openapi_type_guards_1 = require("../../openapi-type-guards");
const vendor_extensions_1 = require("../vendor-extensions");
const naming_1 = require("./naming");
const utils_1 = require("./utils");
const examples_1 = require("../examples");
const map_1 = require("./map");
const discriminator_1 = require("./discriminator");
const property_1 = require("./property");
const external_docs_1 = require("../external-docs");
const interface_1 = require("./interface");
const hierarchy_1 = require("./hierarchy");
function toCodegenObjectSchema(apiSchema, naming, state) {
    if (apiSchema.discriminator && state.generator.allOfStrategy() === types_1.CodegenAllOfStrategy.HIERARCHY) {
        return (0, hierarchy_1.toCodegenHierarchySchema)(apiSchema, naming, state);
    }
    else if (apiSchema.discriminator && state.generator.allOfStrategy() === types_1.CodegenAllOfStrategy.OBJECT && !(state.generator.supportsInheritance() && state.generator.supportsMultipleInheritance())) {
        /*
        If we use the OBJECT allOf strategy, then we need to consider whether we need to turn objects into interfaces if
        they contain a discriminator.

        If we support multiple inheritance, then we don't need an interface as we can have the object containing the discriminator
        as a parent of any members, thus establishing compatibility.

        If we don't support multiple inheritance (or any form of inheritance) then the schema containing the discriminator needs to
        be an interface so any members can be compatible with it.
        */
        return toCodegenObjectSchemaInterface(apiSchema, naming, state);
    }
    else {
        return toCodegenObjectSchemaObject(apiSchema, naming, state);
    }
}
exports.toCodegenObjectSchema = toCodegenObjectSchema;
function toCodegenObjectSchemaObject(apiSchema, naming, state) {
    const { scopedName } = naming;
    const vendorExtensions = (0, vendor_extensions_1.toCodegenVendorExtensions)(apiSchema);
    const nativeType = state.generator.toNativeObjectType({
        type: apiSchema.type,
        format: apiSchema.format,
        schemaType: types_1.CodegenSchemaType.OBJECT,
        scopedName,
        vendorExtensions,
    });
    let result = Object.assign(Object.assign(Object.assign({}, (0, naming_1.extractNaming)(naming)), (0, utils_1.extractCodegenSchemaCommon)(apiSchema, state)), { abstract: false, properties: null, additionalProperties: null, examples: null, discriminator: null, discriminatorValues: null, polymorphic: false, children: null, vendorExtensions, externalDocs: (0, external_docs_1.toCodegenExternalDocs)(apiSchema), nativeType, type: 'object', format: apiSchema.format || null, schemaType: types_1.CodegenSchemaType.OBJECT, interface: null, implements: null, parents: null, schemas: null, component: null, deprecated: false });
    result = handleObjectCommon(apiSchema, naming, result, state);
    // TODO we previous had an issue where a member of a discriminator didn't discover the discriminator
    // because of order-of-operations between populating model.discriminator and the member being created
    // and looking for it. If that happens again, this is one approach to work around it.
    // if (result.discriminator && result.children) {
    // 	for (const aSchema of result.children) {
    // 		if (isCodegenDiscriminatableSchema(aSchema)) {
    // 			addToDiscriminator(result, aSchema, state)
    // 		}
    // 	}
    // }
    return result;
}
function toCodegenObjectSchemaInterface(apiSchema, naming, state) {
    const { scopedName } = naming;
    const vendorExtensions = (0, vendor_extensions_1.toCodegenVendorExtensions)(apiSchema);
    const nativeType = state.generator.toNativeObjectType({
        type: apiSchema.type,
        format: apiSchema.format,
        schemaType: types_1.CodegenSchemaType.INTERFACE,
        scopedName,
        vendorExtensions,
    });
    let result = Object.assign(Object.assign(Object.assign({}, (0, naming_1.extractNaming)(naming)), (0, utils_1.extractCodegenSchemaCommon)(apiSchema, state)), { properties: null, additionalProperties: null, examples: null, discriminator: null, polymorphic: false, discriminatorValues: null, children: null, vendorExtensions, externalDocs: (0, external_docs_1.toCodegenExternalDocs)(apiSchema), nativeType, type: 'object', format: apiSchema.format || null, schemaType: types_1.CodegenSchemaType.INTERFACE, implementation: null, implementors: null, parents: null, schemas: null, component: null, deprecated: false });
    result = handleObjectCommon(apiSchema, naming, result, state);
    // TODO we previous had an issue where a member of a discriminator didn't discover the discriminator
    // because of order-of-operations between populating model.discriminator and the member being created
    // and looking for it. If that happens again, this is one approach to work around it.
    // if (result.discriminator && result.implementors) {
    // 	for (const aSchema of result.implementors) {
    // 		if (isCodegenDiscriminatableSchema(aSchema)) {
    // 			addToDiscriminator(result, aSchema, state)
    // 		}
    // 	}
    // }
    if (!result.discriminator) {
        /* As this schema was in the original specification, we should make a concrete implementation of it
           in case some code expects to use it.
         */
        (0, interface_1.toCodegenInterfaceImplementationSchema)(result, { allowAbstract: false }, state);
    }
    return result;
}
function handleObjectCommon(apiSchema, naming, schema, state) {
    schema.examples = (0, examples_1.toCodegenExamples)(apiSchema.example, undefined, undefined, schema, state);
    if ((0, openapi_type_guards_1.isOpenAPIv3SchemaObject)(apiSchema, state.specVersion)) {
        schema.deprecated = apiSchema.deprecated || false;
    }
    /* Must add model to knownSchemas here before we try to load other models to avoid infinite loop
       when a model references other models that in turn reference this model.
     */
    schema = (0, utils_1.addToKnownSchemas)(apiSchema, schema, naming, state);
    schema.properties = (0, property_1.toCodegenProperties)(apiSchema, schema, state) || null;
    if (apiSchema.additionalProperties) {
        /* This schema also has additional properties */
        try {
            const mapSchema = (0, map_1.toCodegenMapSchema)(apiSchema, naming, 'value', schema, state);
            schema.additionalProperties = mapSchema;
        }
        catch (error) {
            state.log(types_1.CodegenLogLevel.WARN, `Failed to generate additional property schema for ${naming.name} ${schema.additionalProperties}: ${error.message}`);
        }
    }
    schema.discriminator = (0, discriminator_1.toCodegenSchemaDiscriminator)(apiSchema, schema, state);
    if (schema.discriminator) {
        schema.polymorphic = true;
    }
    (0, discriminator_1.loadDiscriminatorMappings)(schema, state);
    (0, discriminator_1.discoverDiscriminatorReferencesInOtherDocuments)(apiSchema, state);
    return schema;
}
/**
 * Create a new schema of an object type with the given name, in the given scope, and add it to that scope.
 * @param suggestedName the suggested name to use, but a unique name will be chosen in that scope
 * @param scope the scope in which to create the object, or `null` to create in the global scope
 * @param state
 * @returns
 */
function createObjectSchema(suggestedName, scope, purpose, state) {
    suggestedName = state.generator.toSuggestedSchemaName(suggestedName, {
        purpose,
        schemaType: types_1.CodegenSchemaType.OBJECT,
    });
    const naming = (0, naming_1.toUniqueScopedName)(undefined, suggestedName, scope, undefined, types_1.CodegenSchemaType.OBJECT, state);
    const nativeType = state.generator.toNativeObjectType({
        type: 'object',
        schemaType: types_1.CodegenSchemaType.OBJECT,
        scopedName: naming.scopedName,
        vendorExtensions: null,
    });
    const schema = Object.assign(Object.assign({}, (0, naming_1.extractNaming)(naming)), { type: 'object', format: null, schemaType: types_1.CodegenSchemaType.OBJECT, abstract: false, properties: null, additionalProperties: null, examples: null, discriminator: null, discriminatorValues: null, polymorphic: false, children: null, interface: null, implements: null, parents: null, description: null, title: null, vendorExtensions: null, externalDocs: null, nullable: false, readOnly: false, writeOnly: false, deprecated: false, nativeType, component: null, schemas: null });
    (0, utils_1.addToScope)(schema, scope, state);
    (0, naming_1.usedSchemaName)(naming.scopedName, state);
    return schema;
}
exports.createObjectSchema = createObjectSchema;
