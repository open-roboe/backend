"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCodegenParameters = void 0;
const types_1 = require("@openapi-generator-plus/types");
const openapi_type_guards_1 = require("../openapi-type-guards");
const examples_1 = require("./examples");
const utils_1 = require("./utils");
const vendor_extensions_1 = require("./vendor-extensions");
const idx = __importStar(require("@openapi-generator-plus/indexed-type"));
const schema_1 = require("./schema");
function toCodegenParameters(parameters, pathParameters, scopeName, state) {
    const result = idx.create();
    if (pathParameters) {
        idx.merge(result, pathParameters);
    }
    for (const parameter of parameters) {
        const codegenParameter = toCodegenParameter(parameter, scopeName, state);
        idx.set(result, codegenParameter.name, codegenParameter);
    }
    return idx.nullIfEmpty(result);
}
exports.toCodegenParameters = toCodegenParameters;
function toCodegenParameter(parameter, scopeName, state) {
    const parameterContextName = (0, openapi_type_guards_1.isOpenAPIReferenceObject)(parameter) ? (0, utils_1.nameFromRef)(parameter.$ref, state) : `${scopeName}_${parameter.name}`;
    const originalApiSchema = (0, openapi_type_guards_1.isOpenAPIReferenceObject)(parameter) ? parameter : undefined;
    parameter = (0, utils_1.resolveReference)(parameter, state);
    let schemaUse;
    let examples;
    let defaultValue;
    const parameterIn = parameter.in;
    const required = parameterIn === 'path' ? true : (0, utils_1.convertToBoolean)(parameter.required, false);
    if ((0, openapi_type_guards_1.isOpenAPIV2GeneralParameterObject)(parameter, state.specVersion)) {
        schemaUse = (0, schema_1.toCodegenSchemaUsage)(parameter, state, {
            required: (0, utils_1.convertToBoolean)(parameter.required, false),
            suggestedName: parameterContextName,
            purpose: types_1.CodegenSchemaPurpose.PARAMETER,
            suggestedScope: null,
        });
        examples = null;
        defaultValue = (0, utils_1.toDefaultValue)(parameter.default, schemaUse, state);
    }
    else {
        /* We pass [] as scopeNames so we create any nested models at the root of the models package,
         * as we reference all models relative to the models package, but a parameter is in an
         * operation. TODO it would be nice to improve this; maybe we can declare an enum in an Api
         * interface... we'd just need to make sure that the nativeTypes referring to it were fixed.
         * But we don't know the Api class name at this point. If we knew it, we could perhaps pass
         * the package along with the scope names in all cases.
         * However it's sort of up to the templates to decide where to output models... so does that
         * mean that we need to provide more info to toNativeType so it can put in full package names?
         */
        schemaUse = (0, schema_1.toCodegenSchemaUsage)(parameter.schema || { type: 'string' }, state, {
            required,
            suggestedName: parameterContextName,
            purpose: types_1.CodegenSchemaPurpose.PARAMETER,
            suggestedScope: null,
        });
        examples = (0, examples_1.toCodegenExamples)(parameter.example, parameter.examples, undefined, schemaUse, state);
        defaultValue = null;
    }
    const vendorExtensions = (0, vendor_extensions_1.toCodegenVendorExtensions)(parameter);
    const style = parameter.style || defaultEncodingStyle(parameterIn);
    const encoding = {
        style,
        explode: (0, utils_1.convertToBoolean)(parameter.explode, style === types_1.CodegenEncodingStyle.FORM),
        allowReserved: (0, utils_1.convertToBoolean)(parameter.allowReserved, false),
        allowEmptyValue: (0, utils_1.convertToBoolean)(parameter.allowEmptyValue, false),
        vendorExtensions,
    };
    if ((encoding.style === types_1.CodegenEncodingStyle.SPACE_DELIMITED || encoding.style === types_1.CodegenEncodingStyle.PIPE_DELIMITED) && !(0, types_1.isCodegenArraySchema)(schemaUse.schema) && !(0, types_1.isCodegenObjectSchema)(schemaUse.schema)) {
        throw new Error(`Encoding style "${encoding.style}" is not appropriate schema type ${schemaUse.schema.schemaType} in parameter "${parameter.name}"`);
    }
    else if (encoding.style === types_1.CodegenEncodingStyle.DEEP_OBJECT && !(0, types_1.isCodegenObjectSchema)(schemaUse.schema)) {
        throw new Error(`Encoding style "${encoding.style}" is not appropriate for schema type ${schemaUse.schema.schemaType} in parameter "${parameter.name}"`);
    }
    const result = {
        name: state.generator.toIdentifier(parameter.name),
        serializedName: parameter.name,
        in: parameterIn,
        description: parameter.description || null,
        required,
        schema: schemaUse.schema,
        nativeType: schemaUse.nativeType,
        collectionFormat: (0, openapi_type_guards_1.isOpenAPIV2GeneralParameterObject)(parameter, state.specVersion) ? parameter.collectionFormat || null : null,
        examples,
        defaultValue,
        nullable: false,
        readOnly: false,
        writeOnly: false,
        deprecated: (0, utils_1.convertToBoolean)(parameter.deprecated, false),
        vendorExtensions,
        encoding,
        isQueryParam: parameter.in === 'query',
        isPathParam: parameter.in === 'path',
        isHeaderParam: parameter.in === 'header',
        isCookieParam: parameter.in === 'cookie',
        isFormParam: parameter.in === 'formData',
    };
    if (originalApiSchema) {
        /* We allow some properties to be overriden on a $ref */
        const originalApiSchemaAsSchemaObject = originalApiSchema;
        if (originalApiSchemaAsSchemaObject.required) {
            result.required = true;
        }
        if (originalApiSchemaAsSchemaObject.deprecated) {
            result.deprecated = true;
        }
    }
    return result;
}
function defaultEncodingStyle(parameterIn) {
    switch (parameterIn) {
        case 'query': return types_1.CodegenEncodingStyle.FORM;
        case 'path': return types_1.CodegenEncodingStyle.SIMPLE;
        case 'header': return types_1.CodegenEncodingStyle.SIMPLE;
        case 'cookie': return types_1.CodegenEncodingStyle.FORM;
        case 'formData': return types_1.CodegenEncodingStyle.FORM;
        case 'body': return types_1.CodegenEncodingStyle.FORM; /* This is an OpenAPIv2 thing that we repair later */
    }
    throw new Error(`Unsupported 'in' for parameter: ${parameterIn}`);
}
