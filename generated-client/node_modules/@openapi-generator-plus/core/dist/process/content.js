"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyCodegenContentEncoding = exports.findAllContentMediaTypes = exports.toCodegenContentArray = void 0;
const types_1 = require("@openapi-generator-plus/types");
const __1 = require("..");
const utils_1 = require("@openapi-generator-plus/utils");
const examples_1 = require("./examples");
const headers_1 = require("./headers");
const media_types_1 = require("./media-types");
const schema_1 = require("./schema");
const array_1 = require("./schema/array");
const naming_1 = require("./schema/naming");
const object_1 = require("./schema/object");
const property_1 = require("./schema/property");
const string_1 = require("./schema/string");
const usage_1 = require("./schema/usage");
const utils_2 = require("./schema/utils");
const utils_3 = require("./utils");
const vendor_extensions_1 = require("./vendor-extensions");
function toCodegenContentArray(content, required, suggestedSchemaName, purpose, scope, state) {
    const result = [];
    for (const mediaType in content) {
        const mediaTypeContent = content[mediaType];
        const item = toCodegenContent(mediaType, mediaTypeContent, required, suggestedSchemaName, purpose, scope, state);
        result.push(item);
    }
    return result;
}
exports.toCodegenContentArray = toCodegenContentArray;
function toCodegenContent(mediaType, mediaTypeContent, required, suggestedSchemaName, purpose, scope, state) {
    if (!mediaTypeContent.schema) {
        return {
            mediaType: (0, media_types_1.toCodegenMediaType)(mediaType),
            encoding: null,
            required,
            schema: null,
            nativeType: null,
            examples: null,
        };
    }
    const schemaUse = (0, schema_1.toCodegenSchemaUsage)(mediaTypeContent.schema, state, {
        required,
        suggestedName: suggestedSchemaName,
        purpose,
        suggestedScope: scope,
    });
    const examples = (0, examples_1.toCodegenExamples)(mediaTypeContent.example, mediaTypeContent.examples, mediaType, schemaUse, state);
    const item = {
        mediaType: (0, media_types_1.toCodegenMediaType)(mediaType),
        encoding: null,
        required,
        schema: schemaUse.schema,
        nativeType: schemaUse.nativeType,
        examples,
    };
    applyCodegenContentEncoding(item, mediaTypeContent.encoding, state);
    return item;
}
function findAllContentMediaTypes(contents) {
    if (!contents || !contents.length) {
        return undefined;
    }
    return contents.reduce((existing, content) => content.mediaType ? [...existing, content.mediaType] : existing, []);
}
exports.findAllContentMediaTypes = findAllContentMediaTypes;
/**
 * Determine the content encoding type to use with the given media type, or null if content encoding isn't supported.
 * @param mediaType
 * @returns
 */
function contentEncodingType(mediaType) {
    if ((0, media_types_1.isMultipart)(mediaType)) {
        return types_1.CodegenContentEncodingType.MULTIPART;
    }
    else if (mediaType.mimeType === 'application/x-www-form-urlencoded') {
        return types_1.CodegenContentEncodingType.WWW_FORM_URLENCODED;
    }
    else {
        return null;
    }
}
/**
 * Apply information about encoding, and any required defaults for content encoding, to the given CodegenContent; modifying it.
 * @param content
 * @param encodingSpec
 * @param state
 * @returns
 */
function applyCodegenContentEncoding(content, encodingSpec, state) {
    if (!content.schema) {
        throw new Error('Cannot apply content encoding to content without a schema');
    }
    const type = contentEncodingType(content.mediaType);
    if (!type) {
        if (encodingSpec) {
            state.log(types_1.CodegenLogLevel.WARN, `encoding object found but not supported on content type ${content.mediaType.mediaType}`);
        }
        content.encoding = null;
        return;
    }
    if (!(0, types_1.isCodegenObjectSchema)(content.schema)) {
        state.log(types_1.CodegenLogLevel.WARN, `encoding object found but content schema is not an object for content type ${content.mediaType.mediaType}`);
        return;
    }
    if (!encodingSpec) {
        encodingSpec = {};
    }
    const allProperties = (0, utils_1.uniquePropertiesIncludingInherited)(content.schema);
    /* Ensure `encodings` has one entry per property in the schema, as we make encodings a complete representation of the schema */
    for (const name in allProperties) {
        if (!encodingSpec[name]) {
            encodingSpec[name] = {};
        }
        const encoding = encodingSpec[name];
        if (!encoding.contentType) {
            encoding.contentType = defaultContentType(allProperties[name]);
        }
    }
    const supportsHeaders = type === types_1.CodegenContentEncodingType.MULTIPART;
    const encoding = {
        type,
        mediaType: content.mediaType,
        properties: {},
    };
    for (const name in encodingSpec) {
        const property = __1.idx.get(allProperties, name);
        if (!property) {
            state.log(types_1.CodegenLogLevel.WARN, `encoding object specifies unknown property "${name}" for content type ${content.mediaType.mediaType}`);
            continue;
        }
        const propertyEncodingSpec = encodingSpec[name];
        const contentType = propertyEncodingSpec.contentType || 'text/plain';
        const style = propertyEncodingSpec.style || types_1.CodegenEncodingStyle.FORM;
        const propertyEncoding = {
            contentType,
            headers: supportsHeaders ? (0, headers_1.toCodegenHeaders)(propertyEncodingSpec.headers, state) : null,
            style,
            explode: (0, utils_3.convertToBoolean)(propertyEncodingSpec.explode, style === types_1.CodegenEncodingStyle.FORM),
            allowReserved: (0, utils_3.convertToBoolean)(propertyEncodingSpec.allowReserved, false),
            allowEmptyValue: false,
            vendorExtensions: (0, vendor_extensions_1.toCodegenVendorExtensions)(propertyEncodingSpec),
            property: property,
            valueProperty: null,
            filenameProperty: null,
            headerProperties: null,
        };
        encoding.properties[name] = propertyEncoding;
    }
    content.encoding = encoding;
    if (requiresMetadata(content.encoding)) {
        const newSchema = (0, object_1.createObjectSchema)(content.mediaType.mimeType, content.schema, types_1.CodegenSchemaPurpose.GENERAL, state);
        newSchema.properties = __1.idx.create(allProperties);
        for (const name of __1.idx.allKeys(newSchema.properties)) {
            const propertyEncoding = __1.idx.get(encoding.properties, name);
            if (propertyRequiresMetadata(encoding, propertyEncoding)) {
                const originalProperty = allProperties[name];
                const partSchema = (0, object_1.createObjectSchema)(`${name}_part`, newSchema, types_1.CodegenSchemaPurpose.GENERAL, state);
                /* Duplicate the property so we don't change the original */
                const partProperty = Object.assign({}, originalProperty);
                if (originalProperty.schema.schemaType === types_1.CodegenSchemaType.ARRAY) {
                    const partComponentSchemaUsage = (0, usage_1.createSchemaUsage)(partSchema, {
                        required: true,
                        nullable: originalProperty.schema.component.nullable,
                        readOnly: false,
                        writeOnly: false,
                    }, state);
                    partProperty.schema = (0, array_1.createArraySchema)(partComponentSchemaUsage, state);
                    partProperty.nativeType = (0, usage_1.transformNativeTypeForUsage)(partProperty, state);
                }
                else {
                    const partSchemaUsage = (0, usage_1.createSchemaUsage)(partSchema, {
                        required: originalProperty.required,
                        nullable: originalProperty.nullable,
                        readOnly: originalProperty.readOnly,
                        writeOnly: originalProperty.writeOnly,
                    }, state);
                    Object.assign(partProperty, partSchemaUsage);
                }
                partProperty.initialValue = state.generator.initialValue((0, utils_3.toCodegenInitialValueOptions)(partProperty));
                __1.idx.set(newSchema.properties, name, partProperty);
                (0, utils_2.addToScope)(partSchema, newSchema, state);
                propertyEncoding.property = partProperty;
                partSchema.properties = __1.idx.create();
                /* Value property contains the actual value */
                const valueProperty = (0, property_1.createCodegenProperty)('value', Object.assign(Object.assign({}, (originalProperty.schema.component ? originalProperty.schema.component : originalProperty)), { required: true, nullable: false, readOnly: false, writeOnly: false }), state);
                (0, property_1.addCodegenProperty)(partSchema.properties, valueProperty, state);
                propertyEncoding.valueProperty = valueProperty;
                /* Filename property */
                if (propertySupportsFilenameMetadata(encoding, propertyEncoding)) {
                    const filenameProperty = (0, property_1.createCodegenProperty)('filename', (0, string_1.createStringSchemaUsage)(undefined, {
                        required: false,
                    }, state), state);
                    (0, property_1.addCodegenProperty)(partSchema.properties, filenameProperty, state);
                    propertyEncoding.filenameProperty = filenameProperty;
                }
                /* Header properties */
                if (propertyEncoding.headers) {
                    propertyEncoding.headerProperties = __1.idx.create();
                    for (const [headerName, header] of __1.idx.iterable(propertyEncoding.headers)) {
                        const headerUsage = Object.assign(Object.assign({}, (0, utils_3.extractCodegenSchemaInfo)(header.schema)), { schema: header.schema, defaultValue: header.defaultValue, examples: header.examples, required: header.required });
                        headerUsage.nativeType = (0, usage_1.transformNativeTypeForUsage)(headerUsage, state);
                        let headerProperty = (0, property_1.createCodegenProperty)(headerName, headerUsage, state);
                        let uniquePropertyName = (0, naming_1.toUniqueName)(headerProperty.name, undefined, partSchema.properties, state);
                        if (uniquePropertyName !== headerProperty.name) {
                            headerProperty = (0, property_1.createCodegenProperty)(`${headerName}_header`, headerUsage, state);
                            uniquePropertyName = (0, naming_1.toUniqueName)(headerProperty.name, undefined, partSchema.properties, state);
                        }
                        headerProperty.name = uniquePropertyName;
                        headerProperty.serializedName = uniquePropertyName; /* We don't use the serialized name, but it impacts the key it gets put in in properties */
                        (0, property_1.addCodegenProperty)(partSchema.properties, headerProperty, state);
                        __1.idx.set(propertyEncoding.headerProperties, headerName, headerProperty);
                    }
                }
            }
        }
        /* Use the new schema in our content */
        Object.assign(content, (0, usage_1.createSchemaUsage)(newSchema, {
            required: false,
            nullable: false,
            readOnly: false,
            writeOnly: false,
        }, state));
    }
}
exports.applyCodegenContentEncoding = applyCodegenContentEncoding;
/**
 * Determine whether the given content encoding requires us to add additional metadata to the schema,
 * such as for headers that might be required, or filenames.
 * @param encoding
 * @returns
 */
function requiresMetadata(encoding) {
    if (encoding.type !== types_1.CodegenContentEncodingType.MULTIPART) {
        return false;
    }
    for (const name of __1.idx.allKeys(encoding.properties)) {
        const propertyEncoding = encoding.properties[name];
        if (propertyRequiresMetadata(encoding, propertyEncoding)) {
            return true;
        }
    }
    return false;
}
function propertyRequiresMetadata(encoding, propertyEncoding) {
    if (propertyEncoding.headers) {
        return true;
    }
    if (propertySupportsFilenameMetadata(encoding, propertyEncoding)) {
        return true;
    }
    return false;
}
function propertySupportsFilenameMetadata(encoding, propertyEncoding) {
    if (encoding.mediaType.mimeType === 'multipart/form-data' && propertyEncoding.contentType === 'application/octet-stream') {
        return true;
    }
    return false;
}
/**
 * Returns the default content type to use for a multipart part witht he given schema, using defaults
 * described in https://swagger.io/specification/#encoding-object
 */
function defaultContentType(usage) {
    if (usage.schema.schemaType === types_1.CodegenSchemaType.BINARY) {
        return 'application/octet-stream';
    }
    else if (usage.schema.schemaType === types_1.CodegenSchemaType.OBJECT) {
        return 'application/json';
    }
    else if (usage.schema.schemaType === types_1.CodegenSchemaType.ARRAY && usage.schema.component) {
        return defaultContentType(usage.schema.component);
    }
    return 'text/plain';
}
