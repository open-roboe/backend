"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.javaLikeGenerator = exports.options = exports.identifierCamelCase = exports.classCamelCase = exports.identifierSafe = void 0;
const types_1 = require("@openapi-generator-plus/types");
const generator_common_1 = require("@openapi-generator-plus/generator-common");
const change_case_1 = require("change-case");
const generator_common_2 = require("@openapi-generator-plus/generator-common");
/** Returns the string converted to a string that is safe as an identifier in java-like languages */
function identifierSafe(value) {
    if (typeof value !== 'string') {
        throw new Error(`identifierSafe called with non-string: ${typeof value} (${value})`);
    }
    /* Add a prefix if the identifier starts with illegal characters */
    if (value.match(/^[^a-zA-Z_]/)) {
        value = `_${value}`;
    }
    /* Convert any illegal characters to underscores, as long as they're followed by legal characters */
    value = value.replace(/[^a-zA-Z0-9_]([a-zA-Z0-9_])/g, '_$1');
    /* Remove any remaining illegal characters */
    value = value.replace(/[^a-zA-Z0-9_]/g, '');
    return value;
}
exports.identifierSafe = identifierSafe;
/**
 * Camel case and capitalize suitable for a class name. Doesn't change existing
 * capitalization in the value.
 * e.g. "FAQSection" remains "FAQSection", and "faqSection" will become "FaqSection"
 * @param value string to be turned into a class name
 */
function classCamelCase(value) {
    return identifierSafe((0, generator_common_1.pascalCase)(identifierSafe(value)));
}
exports.classCamelCase = classCamelCase;
function identifierCamelCase(value) {
    return identifierSafe((0, generator_common_1.camelCase)(identifierSafe(value)));
}
exports.identifierCamelCase = identifierCamelCase;
function options(config, context) {
    const result = {
        apiClassPrefix: (0, generator_common_1.configString)(config, 'apiClassPrefix', undefined),
        modelClassPrefix: (0, generator_common_1.configString)(config, 'modelClassPrefix', undefined),
        constantStyle: (0, generator_common_1.configString)(config, 'constantStyle', context.defaultConstantStyle),
    };
    return result;
}
exports.options = options;
function javaLikeGenerator(config, context) {
    const generatorOptions = options(config, context);
    function applyReservedWords(input, transform) {
        let result = transform(input);
        const reservedWords = context.reservedWords ? context.reservedWords() : [];
        while (reservedWords.indexOf(result) !== -1) {
            result = transform(`a_${input}`);
        }
        return result;
    }
    const cg = (0, generator_common_2.commonGenerator)(config, context);
    return {
        toClassName: (name) => {
            return applyReservedWords(name, classCamelCase);
        },
        toIdentifier: (name) => {
            return applyReservedWords(name, identifierCamelCase);
        },
        toConstantName: (name) => {
            if (!name) {
                return context.generator().toConstantName('empty');
            }
            const constantStyle = generatorOptions.constantStyle;
            switch (constantStyle) {
                case "allCaps" /* allCaps */:
                    return applyReservedWords(name, input => identifierSafe((0, change_case_1.constantCase)(identifierSafe(input)).replace(/_/g, '')));
                case "camelCase" /* camelCase */:
                    return applyReservedWords(name, input => identifierCamelCase(input));
                case "snake" /* allCapsSnake */:
                    return applyReservedWords(name, input => identifierSafe((0, change_case_1.constantCase)(identifierSafe(input))));
                case "pascalCase" /* pascalCase */:
                    return applyReservedWords(name, input => identifierSafe((0, generator_common_1.pascalCase)(identifierSafe(input))));
                default:
                    throw new Error(`Invalid valid for constantStyle: ${constantStyle}`);
            }
        },
        toSchemaName: (name, options) => {
            let result = cg.toSchemaName(name, options);
            result = context.generator().toClassName(result);
            if ((options.schemaType === types_1.CodegenSchemaType.OBJECT || options.schemaType === types_1.CodegenSchemaType.INTERFACE || options.schemaType === types_1.CodegenSchemaType.WRAPPER || options.schemaType === types_1.CodegenSchemaType.ALLOF || options.schemaType === types_1.CodegenSchemaType.ANYOF || options.schemaType === types_1.CodegenSchemaType.ONEOF || options.schemaType === types_1.CodegenSchemaType.ENUM) && generatorOptions.modelClassPrefix) {
                result = generatorOptions.modelClassPrefix + result;
            }
            return result;
        },
        toSuggestedSchemaName: (name, options) => {
            if (options.schemaType === types_1.CodegenSchemaType.ENUM) {
                name = `${name}_enum`;
            }
            else if (options.purpose === types_1.CodegenSchemaPurpose.EXTRACTED_INTERFACE) {
                name = `i_${name}`;
            }
            else if (options.purpose === types_1.CodegenSchemaPurpose.ABSTRACT_IMPLEMENTATION) {
                name = `abstract_${name}`;
            }
            else if (options.purpose === types_1.CodegenSchemaPurpose.IMPLEMENTATION) {
                name = `${name}_impl`;
            }
            return cg.toSuggestedSchemaName(name, options);
        },
        toOperationGroupName: (name) => {
            if (generatorOptions.apiClassPrefix) {
                return context.generator().toClassName(`${generatorOptions.apiClassPrefix}_${name}`);
            }
            else {
                return context.generator().toClassName(name);
            }
        },
    };
}
exports.javaLikeGenerator = javaLikeGenerator;
