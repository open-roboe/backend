"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nullIfEmpty = exports.undefinedIfEmpty = exports.merge = exports.size = exports.allValues = exports.allKeys = exports.has = exports.get = exports.set = exports.create = exports.remove = exports.values = exports.iterable = exports.sortValues = exports.isEmpty = exports.filter = exports.find = exports.findEntry = void 0;
function findEntry(ob, predicate) {
    for (const key in ob) {
        const value = ob[key];
        if (predicate(value)) {
            return [key, value];
        }
    }
    return undefined;
}
exports.findEntry = findEntry;
function find(ob, predicate) {
    for (const key in ob) {
        const value = ob[key];
        if (predicate(value)) {
            return value;
        }
    }
    return undefined;
}
exports.find = find;
function filter(ob, predicate) {
    const result = {};
    for (const key in ob) {
        const value = ob[key];
        if (predicate(value)) {
            result[key] = value;
        }
    }
    return result;
}
exports.filter = filter;
function isEmpty(ob) {
    return size(ob) === 0;
}
exports.isEmpty = isEmpty;
function objectEntries(ob) {
    const entries = [];
    for (const key in ob) {
        const value = ob[key];
        entries.push([key, value]);
    }
    return entries;
}
function sortValues(ob, compare) {
    const entries = objectEntries(ob);
    entries.sort((a, b) => compare(a[1], b[1]));
    return create(entries);
}
exports.sortValues = sortValues;
function iterable(ob) {
    return {
        [Symbol.iterator]: () => {
            let i = 0;
            const keys = Object.keys(ob);
            return {
                next: () => {
                    const entry = [keys[i], ob[keys[i]]];
                    i++;
                    if (i <= keys.length) {
                        return {
                            value: entry,
                            done: false,
                        };
                    }
                    else {
                        return {
                            value: undefined,
                            done: true,
                        };
                    }
                },
            };
        },
    };
}
exports.iterable = iterable;
function values(ob) {
    return {
        [Symbol.iterator]: () => {
            let i = 0;
            const keys = Object.keys(ob);
            return {
                next: () => {
                    const value = ob[keys[i]];
                    i++;
                    if (i <= keys.length) {
                        return {
                            value,
                            done: false,
                        };
                    }
                    else {
                        return {
                            value: undefined,
                            done: true,
                        };
                    }
                },
            };
        },
    };
}
exports.values = values;
function remove(ob, key) {
    delete ob[key];
}
exports.remove = remove;
function create(entries) {
    if (!entries) {
        return {};
    }
    else if (Array.isArray(entries)) {
        const result = {};
        for (const entry of entries) {
            result[entry[0]] = entry[1];
        }
        return result;
    }
    else if (typeof entries === 'object') {
        const result = {};
        for (const name in entries) {
            result[name] = entries[name];
        }
        return result;
    }
    else {
        throw new Error(`Unsupported argument to create: ${typeof entries}`);
    }
}
exports.create = create;
function set(ob, key, value) {
    ob[key] = value;
}
exports.set = set;
function get(ob, key) {
    return ob[key];
}
exports.get = get;
function has(ob, key) {
    return Object.keys(ob).indexOf(key) !== -1;
}
exports.has = has;
function allKeys(ob) {
    const result = [];
    for (const key in ob) {
        result.push(key);
    }
    return result;
}
exports.allKeys = allKeys;
function allValues(ob) {
    const result = [];
    for (const key in ob) {
        result.push(ob[key]);
    }
    return result;
}
exports.allValues = allValues;
function size(ob) {
    return Object.keys(ob).length;
}
exports.size = size;
function merge(ob, other) {
    for (const key in other) {
        ob[key] = other[key];
    }
    return ob;
}
exports.merge = merge;
function undefinedIfEmpty(ob) {
    if (!ob) {
        return undefined;
    }
    if (isEmpty(ob)) {
        return undefined;
    }
    return ob;
}
exports.undefinedIfEmpty = undefinedIfEmpty;
function nullIfEmpty(ob) {
    if (!ob) {
        return null;
    }
    if (isEmpty(ob)) {
        return null;
    }
    return ob;
}
exports.nullIfEmpty = nullIfEmpty;
