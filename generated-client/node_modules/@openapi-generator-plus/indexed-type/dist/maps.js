"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nullIfEmpty = exports.undefinedIfEmpty = exports.merge = exports.size = exports.allValues = exports.allKeys = exports.has = exports.get = exports.set = exports.create = exports.remove = exports.values = exports.iterable = exports.sortValues = exports.isEmpty = exports.filter = exports.find = exports.findEntry = void 0;
function findEntry(map, predicate) {
    for (const entry of map) {
        if (predicate(entry[1])) {
            return entry;
        }
    }
    return undefined;
}
exports.findEntry = findEntry;
function find(map, predicate) {
    for (const entry of map) {
        if (predicate(entry[1])) {
            return entry[1];
        }
    }
    return undefined;
}
exports.find = find;
function filter(map, predicate) {
    const result = new Map();
    for (const entry of map) {
        if (predicate(entry[1])) {
            result.set(entry[0], entry[1]);
        }
    }
    return result;
}
exports.filter = filter;
function isEmpty(map) {
    return size(map) === 0;
}
exports.isEmpty = isEmpty;
function sortValues(map, compare) {
    return new Map([...map.entries()].sort((a, b) => compare(a[1], b[1])));
}
exports.sortValues = sortValues;
function iterable(map) {
    return map;
}
exports.iterable = iterable;
function values(map) {
    return map.values();
}
exports.values = values;
function remove(map, key) {
    map.delete(key);
}
exports.remove = remove;
function create(entries) {
    if (!entries) {
        return new Map();
    }
    else if (Array.isArray(entries)) {
        return new Map(entries);
    }
    else if (entries instanceof Map) {
        return new Map(entries);
    }
    else {
        throw new Error(`Unsupported argument to create: ${typeof entries}`);
    }
}
exports.create = create;
function set(map, key, value) {
    map.set(key, value);
}
exports.set = set;
function get(map, key) {
    return map.get(key);
}
exports.get = get;
function has(map, key) {
    return map.has(key);
}
exports.has = has;
function allKeys(map) {
    return [...map.keys()];
}
exports.allKeys = allKeys;
function allValues(map) {
    return [...map.values()];
}
exports.allValues = allValues;
function size(map) {
    return map.size;
}
exports.size = size;
function merge(map, other) {
    for (const entry of other) {
        map.set(entry[0], entry[1]);
    }
    return map;
}
exports.merge = merge;
function undefinedIfEmpty(map) {
    if (!map) {
        return undefined;
    }
    if (isEmpty(map)) {
        return undefined;
    }
    return map;
}
exports.undefinedIfEmpty = undefinedIfEmpty;
function nullIfEmpty(map) {
    if (!map) {
        return null;
    }
    if (isEmpty(map)) {
        return null;
    }
    return map;
}
exports.nullIfEmpty = nullIfEmpty;
