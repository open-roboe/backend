"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.debugStringify = exports.stringify = void 0;
/**
 * Stringify a value using JSON.stringify, but supporting circular data structures and depth pruning
 * @param value
 * @param options
 * @returns
 */
function stringify(value, options = {}) {
    if (value === undefined) {
        return 'undefined';
    }
    else {
        return JSON.stringify(value, refReplacer(options), options.space);
    }
}
exports.stringify = stringify;
function debugStringify(value) {
    return stringify(value, { depth: 2, space: 2 });
}
exports.debugStringify = debugStringify;
/**
 * A replacer function for `JSON.stringify` that manages cycles.
 * Based on https://stackoverflow.com/a/61749783/1951952
 */
function refReplacer(options) {
    // eslint-disable-next-line @typescript-eslint/ban-types
    const paths = new Map();
    let initial;
    // eslint-disable-next-line @typescript-eslint/ban-types
    return function (field, value) {
        if (!value || typeof value !== 'object' || value === null) {
            return value;
        }
        const knownPath = paths.get(value);
        if (knownPath) {
            return `#REF:${knownPath}`;
        }
        if (initial == undefined) {
            initial = value;
            paths.set(this, '$');
        }
        const path = `${paths.get(this)}${field ? (Array.isArray(this) ? `[${field}]` : `.${field}`) : ''}`;
        paths.set(value, path);
        if (options.depth !== undefined && typeof value === 'object') {
            const pathDepth = path.split('.').length;
            if (pathDepth > options.depth) {
                return 'PRUNED';
            }
        }
        return value;
    };
}
